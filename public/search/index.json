[{"content":" # C++内存重叠 内存重叠是指在内存中存在两个或多个区域，他们的地址范围有交叉部分，内存重叠可能会导致程序出现不可预期的行为，腾讯timi测开的三问面试官问到了我这个问题，当时没有回答上，非常的遗憾，现在有机会整理一下，变得更强！\n# 内存重叠的原因 内存重叠的主要原因是指针的使用问题。当使用指针访问内存时，如果指针指向的内存区域与另一个区域有交叉部分，就会产生内存重叠。下图展示了内存拷贝的两种情况：\n第一种情况下，拷贝重叠区域不会出现问题，因为拷贝是一个一个放过去，内容可以正常被拷贝。\n第二种情况下，右边两个字节原有的内容被覆盖了，且没有保存，接下来拷贝的时候已经是被覆盖的内容了。\n举个例子，下面代码片段就会导致内存重叠：\n1 2 3 char str[] = \u0026#34;Hello World\u0026#34;; char* p = str +1; memcpy(p, str, 11); 在上面代码中，定义了字符数组str，并使用p指向str中第二个字符。接着，我们用memcpy函数将str中的11个字符复制到p指向的区域。由于p指向的区域与str有交叉部分，因此就产生了内存重叠。因为memcpy是直接按位复制拷贝，代码如下，所以会遇到情况二，拷贝的是已经被覆盖的内容。\n# 如何避免内存重叠 为了避免内存重叠，尤其要注意：\n尽量避免使用指针，尤其是进行运算和类型转换的时候。 在使用指针时，确保指针指向的内存区域与其他区域没有交叉部分。 在使用安全的内存操作函数，如memcpy_s、memmove等，这些函数可以确保在复制内存是不会产生内存重叠 那memmove如何避免内存重叠的影响呢？以下是memmove的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void *memmove(void *dest, const void *src, size_t n) { char *d = dest; const char *s = src; if(d \u0026lt; s) { while (n--) *d++ = *s++; }else{ //采用倒序拷贝 char *lasts = (char *)s + (n - 1); char *lastd = d + (n - 1); while(n--) *lastd-- = *lasts--; } return dest; } remmove判断如果dest\u0026gt;=src的时候（也就是前面图片的情况2），采用倒序拷贝，避免内容被覆盖导致拷贝不完整的问题。\n原理图如下：\nmemcpy与strcpy都有内存重叠的问题，实际可以根据需要使用memmove\n# 总结 三面时候面试官告诉我这是一道思维题，现在想想也是，只用倒序拷贝就能避免粘贴内容被覆盖。但当时满脑子就是想着怎么避开他，诸如存放在别处再拿回来。笔者当时就走不动道了，现在想想一定给面试官留下了“深刻”的印象吧。以上内容既是逻辑题目，也是基础题目，当时抱着试试的想法是走不通的，还是得深入到位，把基础弄扎实，加油吧。\n","date":"2024-04-03T10:46:10+08:00","permalink":"https://yotom131.github.io/p/c-%E5%86%85%E5%AD%98%E9%87%8D%E5%8F%A0/","title":"C++内存重叠"},{"content":" # Hash 概念：hashing是一个过程，将元素储存的位置转化成一个密码（关键码），这是一个不可逆的过程。在查找的时候每次通过哈希函数得到关键码后可以轻松找到对元素的位置。这样的函数叫做哈希函数，最终构造出的结构叫做哈希表（散列表）。\n# 特性 不可逆：hash存在关键码由多个来源转化而来，无法确定哪个关键码是由哪一个来源转换，所以不可逆。\n运算快：20G高清电影和5K文本文件复杂度相同，运算量都极小。越巧妙的hash函数碰撞越少，空间利用率越高。\n结果均匀：哈希函数计算出来的地址能均匀分布在整个空间中，这是hash函数的设计原则。\n# 常见哈希函数和算法 # 直接定址法： 1 Hash(Key) = A * Key + B 这是最简单的hash函数，直接取直接取关键字本身或者他的线性函数来作为散列地址。\n# 除留余数法： 1 Hash(Key) = Key % capacity 这几乎是最常用的哈希函数，用一个数来对key取模，一般来说capacity的值为容量本身。\n经典应用的哈希算法主要是MD5（128位关键码）、SHA-256（256位关键码）、SHA-512（512位关键码）。\n# hash冲突 # 冲突的由来 由于hash函数输出的关键码位数是固定的，将无线的数据输出为有限的数据，那最终得到的结果一定是有重复的，这种输出的关键码重复的时候，就叫做hash冲突，如下图所示。\n# 解决冲突的方法 解决hash冲突的方法主要是以下：\n# 线性测探法 当发生哈希冲突时，从当前位置开始，依次向后查找下一个空闲位置，直至查遍全表。\n但在使用线性测探法的时候，查找、插入、删除的时间复杂度和哈希表的装载因子成正比。并且冲突如果连在一起，很容易产生堆积，查找时会多次重复比较，大大降低查找效率。\n# 二次探测法 基本思路与线性探测法相同，通过二次函数的规律寻找下一个空闲地址。\n# 双重哈希法 发生哈希冲突时，使用另一个哈希函数计算出下一个空闲位置。以上三种属于开放地址法。\n# 链地址法 在hash值重复的情况下，我们也可以考虑将值用链表表示，这样我们在需要查找数据项的时候只需要在对应链表中搜索即可。HashMap在解决储存对象存在hash冲突的时候就是采用链地址法，将hash值相同的对象以链表形式存储。这是一种封闭地址法。\n# 总结 总体而言，哈希是个不可逆的编码过程，以上是一些基本原理，后面涉及到map、unordered_map、dic等键值对的内容时，不单独写博客，希望哈希就此为止，加油！\n","date":"2024-04-03T08:48:15+08:00","permalink":"https://yotom131.github.io/p/hash/","title":"Hash"},{"content":" # 4.2 # 腾讯测开三面总结： ​\t4.1的面试凉的很透彻，明明就差最后一步了，哎。计算机基础没打牢固，c++基础没有打牢固，从这两方面入手抓吧。\n内存重叠部分请点击此处。\nhash部分请点击此处。\n# C++: # 指针和引用： 1 2 3 4 5 6 7 8 9 10 11 12 13 //定义和声明 //此处是指针 int x = 10; int *ptr = \u0026amp;x; //此处是引用，相当于别称 int y = 20; int \u0026amp;ref = y;//引用相当于别称 //使用和操作 int value = *ptr;//获取指针指向的值 int address = \u0026amp;x;//获取x的地址 int newValue = ref;//获取引用的值 空值和空引用：\n指针可以为空（nullptr）。\n引用则必须在声明时初始化，且不能后续改变引用对象，因此没有空引用的概念。\n可变性：\n指针可以改变指向至不同的内存地址。\n引用一旦被初始化，将一直引用同一个对象，不能改变，值可以跟着引用对象改变。\n用途：\n指针通常用于动态内存分配、数组操作、函数参数传递。\n引用通常用于函数参数传递、操作符重载以及创建别名。\n# 数据类型 整形：short int long和long long\nc++数据长度标准：\nshort至少16位，通常为16位。 int至少和short一样长，通常为32位。 long至少32位，且至少和int一样长，通常为32位。 long long至少64位，且至少和long一样长，通常为64位。 在使用8位字节的系统中，1 byte = 8 bit\n可以根据sizeof()来判断数据类型的长度：\n1 2 cout \u0026lt;\u0026lt; \u0026#34;int is \u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; \u0026#34; bytes. \\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;short is \u0026#34; \u0026lt;\u0026lt; sizeof(short) \u0026lt;\u0026lt; \u0026#34; bytes. \\n\u0026#34;; 头文件climits定义了符号常量：例如INT_MAX代表int最大值，INT_MIN代表int最小值 无符号类型\n不储存负数值的整形，可以增大变量存储的最大值，数据长度一致。\n# 关键字 const关键字\n被const修饰的值不能改变，只读变量。必须在定义的时候就给他赋初值。\n1. 常量指针（底层const）\n定义一个指针，指向一个只读的对象，不能通过常量指针来改变这个对象的值。常量指针强调的是指针所指对象的不可改变性。\n特点：*靠近变量名。\n形式：\nconst 数据类型 *指针变量 = 变量名 数据类型 const *指针变量 = 变量名 例如：\n1 2 3 4 5 6 7 int temp = 10; const int* a = \u0026amp;temp; int const *a = \u0026amp;temp; //更改: *a = 9;//错误：只读对象 temp = 9;//正确 2. 指针常量（顶层const）\n定义一个指针，值只能在定义的时候初始化，其他地方不能改变。强调指针的不可改变性。\n特点：*靠近变量类型。\n形式：\n数据类型 * const 指针变量 = 变量名 例如：\n1 2 3 4 5 6 7 int temp = 10; int temp1 = 12; int* const p = \u0026amp;temp; //更改： p = \u0026amp;temp1;//错误 *p = 9;//正确 ","date":"2024-04-02T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.4.2/","title":"2024.4.2"},{"content":" # 3.26 ​\t今天一早上就收到了面试通过的消息，老实说十分激动，并且很期待下一次面试，但因为基础一般的原因，不是很清楚下次面试还会不会这样了解项目情况而少了解基础，总之都得练练，刷题方面的话，日常做两道题。\n昨天的两道哈希表的题目进行了完成，了解到set的insert插入和count统计，并且知道set是存储唯一值的。 移动0， 卡了一会，正确思路是把非0数挨个移到前面去，面试后面一天要重新复习。 移掉K位数字，没做出来，应该是贪心+单调栈，贪心算法不明白是什么，这是个缺点，今晚尽量明白。 ","date":"2024-03-26T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.3.26/","title":"2024.3.26"},{"content":" # 3.25 ​\t今天早上起来最后学习了一会计算机网络相关的知识，重温了一些算法，我对这些算法的记忆还不够深刻，4月初将迎来蓝桥杯，在那个时候需要一定的功底去发展，最好能打一个国奖，这样子对于之后的应聘应该会有很多帮助。\n​\t下午进行了面试，出人意料的是没有考许多八股文，基本上是我自己在阐述。有问到深度学习、transfomer机制这些东西，这些事面试官比较感兴趣的，但我在过程中的表现只能说比较的浅薄，最后捏了一个会的快排，这个让我看见似乎面试官并不会看到我的桌面，后面如果有问题也许可以使用查的方式去完成。但胜任岗位方面需要了解游戏项目的测试自动化、多注意力机制、transformer这些东西，可能会更加地吸引面试官的注意力，就像他们在招聘的时候写着图像处理原理，计算机图形学相关能力。这次面试一直没通知我过，很有可能是在排序中，我并没有表现得那么出色，如果过了，下轮面试在复习好基础后可以着重去了解测试自动化和多注意力机制这方面的东西，不然口头讲述实在是空白无力，而且后面还要面三次。\n​\t如果没有过的话，一方面来说是一场悲报，因为这次面试并不像常规面试一样，而是着重挑了面试官自己想了解的部分，而这些部分我自己属于半懂不懂的状态。后面的反问环节也没有提前准备，只能说下次好好准备吧，这次没过的话其实并不意外，虽然我自己感觉良好，但事实上并没有给出面试官想要的答案。\n​\t今天再刷两道题，然后结束！明天开始多补补计算机网络和操作系统的知识，以免后面考到了。\n今晚因为打卡睡了一道题目，128.最长连续序列，哈希表来做。 第二题也是同理，找到序列中第一个不重复数字的序号，哈希表，明天弄懂。 ","date":"2024-03-25T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.3.25/","title":"2024.3.25"},{"content":" # 3.24日记 ​\t有一些内容昨天忘了提，首先是hash表查找元素可以通过auto it = hash.find(\u0026ldquo;key\u0026rdquo;)，然后判断it是否是hash.end()来确定是否存在这个键。接着他的遍历方式是for(auto it = hash.bedin(); it!= hash.end(); ++it)，或者for(const auto\u0026amp; pair : myMap) 这样的方式遍历，通过hash-\u0026gt;first, hash-\u0026gt;second这样来访问键值对，通过hash.erase()来删除指定键的元素，通过hash.insert(make_pair(\u0026ldquo;key\u0026rdquo;, val))的方式或者hash.emplace(\u0026ldquo;key\u0026rdquo;, val)的方式来添加元素。\n​\t此外，另一个常用的vector容器，可以用for(int element : vec)这样的方式遍历，也可以用索引值for(size_t i = 0; i \u0026lt; vec.size(); i++)这样的方式来遍历。此外还有迭代器，但那个接触不多，可以先不用。\n今天第一道题目是hash表的延申，字母异位词分组，目前水平还是太低了，借助GPT倒是完成了，我的思路是把相同字母的值用键值对的方式存起来，哪些字母组对应了一些值的数组，最后通过把键值对的值赋值给二维向量解决。继续加油吧。 今天第二道题目是有效的括号，属于栈的应用，题目完美符合栈的特点，粗心的错误是在于stk.push(*it)时候，注意根据类型push不同的符号。 今天上午学习了归并排序，并复习了昨天的一些题目，许多题目才一天就有些生疏不知道如何下手了，需要在学习的同时加强巩固。归并的思路是先递归再合并，合并的时候通过双指针指向两组数据的开头，通过对比大小合并，然后将临时数组的值还给原数组，最终完成算法。 顺着合并的思路下午学习了合并K和升序链表，学到了许多新的知识，比如创建虚拟表头，然后删除等，最后重新学习了下vector的几个成员函数，front(), at(), size(), empty(), back(), begin(), end()。并且接着学习到了可以通过int* arr = new int 这样的形式给指针分配动态内存。最后学习了递归方法，希望能常看看这些题目. 然后是一些DP问题，最少的硬币数目，不同路径，两种dp问题，最优解和计数。 ","date":"2024-03-24T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.3.24/","title":"2024.3.24"},{"content":" # 3.23日记 距离腾讯测试开发岗位还有两天不到的时间，现在内心十分紧张，因为技术栈并不多，项目也并没有很匹配。目前主要要求的三个科目是计算机网络、操作系统、算法与数据结构。\n今天学的内容是：\n快速排序、插入排序、希尔排序。快速排序主要思路是找到一个基准值，将大于他的和小于他的放在值得两边。插入排序就像斗地主一样，从第二张牌开始，每次从右往左跟左边比大小，小就往左边换，直到把最右边的值放在合适的位置。希尔排序主题思路与插入排序是一致的，主要区别在于把值分成了多组，用gap来一组组分好位置，当gap为1时，就是插入排序本身。 二叉树的中序遍历。这是力扣的一道题目。重温了vector的使用，和树的结点构造。大体上了解了构造函数的意义，以及中序遍历两种实现思路：递归和迭代。递归每次把左子放入函数，中间存自身，最后放右子即可。迭代则需要一个栈，用来模拟中序遍历的过程，每次空了，就弹出栈顶，记录值，最后返回值即可。 两数之和。这是力扣100的第一题，可以经典的两轮遍历做出来。也可以用hash表来做，对于每一个数值，通过auto it = hash.find(target - nums[i])，判断it值是否是hash.end()来看是否找到了合适的值。顺带了解了，map是有序的，unordered_map可以是无序的哈希表来使用。 每日一题，力扣2549.统计桌面上不同的数字，这是一个可以用简单枚举法完成的问题，但是因为老是先看答案，我已经丧失了思考的过程，要重新锻炼我的编程能力。学习到通过accumulate函数将vector首位累加，不必再使用for遍历完成。此外这道题侧面告诉我，使用数学公式进行简化会更有效果。只有n==1的情况下输出1，其他情况n-1。 总体来说，欠缺的东西还很多，离测试开发的面试要求可能还达不到，加油变强吧少年。\n","date":"2024-03-23T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.3.23/","title":"2024.3.23"}]
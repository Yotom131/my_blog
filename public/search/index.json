[{"content":" # 4.4 # 今日事项 重新翻阅C++primer，主要是输入输出的部分，巩固基础 对于C++八股文中的关键字部分，做了许多补充，主要是const、static等等 借助一道常见的面试题，梳理了计算机网络面试题目框架 # 总结 总体而言，今天的三个部分都比较基础，内容并不算多，但也需要消化。可能是因为清明节到了，我显得比较怠惰，一天下来大多数时间用来研究这个腾讯子公司的方方面面去了，毕竟下周一就要和HR面试了。不是很清楚是不是这一面就可以确定入职，如果是的话那就是足够幸运。\n今天问了下后面的流程，HR只告诉我上海和深圳的工作地点，都不是在很好的地方，但开发游戏是我很心动的领域。如果能够HR一面就拿到offer，只要薪资不要太低，能承担起我的房租和日常开销，并可能存下一笔钱，那我将光速入职hhh\n总体而言，可能是因为HR直接加我微信了，我没有很大的心思花大量时间看八股文和刷题了，当然也可能是因为清明假期有点心不在焉。但总之如果后面不止HR这一面的话我应该会吃大亏，还是应该适当准备一下腾讯云部门的面试，虽然听说HC好像不多了，不知道我还有没有机会（但真的很想从事游戏方面）。祈祷一下吧，只要待遇还可以，我光速入职！咏鹅十遍！\n","date":"2024-04-04T21:46:46+08:00","permalink":"https://yotom131.github.io/p/2024.4.4/","title":"2024.4.4"},{"content":" # 输入URL并按下回车之后会发生什么？ 这是一道超高频的面试题，可以从这道面试题延伸到计算机网络相关的很多问题。\n# 第一步：输入URL并解析 输入URL后，浏览器会解析出协议、主机、端口、路径等信息，并构建一个HTTP请求（浏览器会根据请求头判断是否有HTTP缓存，并根据是否有缓存来决定是从服务器获取资源还是使用缓存资源）\n这里可以引申到URL的组成部分。\n# 第二步：DNS域名解析 在发送HTTP请求之前，浏览器需要知道想要访问网页（url）对应的IP地址，这就需要DNS域名解析，来将域名解析成对应的IP地址\n# 第三步：建立起TCP连接（三次握手） 客户端和服务器之间进行HTTP请求和HTTP响应过程中，需要建立起TCP连接，TCP连接需要进行三次握手（后续给出相关内容地址）\n这里是重中之重，可以延伸很多问题：为什么不是两次？不是四次？如果第一次握手丢失了会怎么样？三次握手的过程可以携带数据吗？\n# 第四步：浏览器发送HTTP/HTTPS请求到web服务器 这一步也可以延伸到HTTP/HTTPS的区别？请求的方式？请求的状态码？等等相关内容\n# 第五步：服务器处理HTTP请求并返回HTTP报文 HTTP响应报文和状态码也是常考内容\n服务器会接受请求，将其传递给请求处理程序并发送HTTP相应，一般响应报文包含：请求的网页以及状态码、压缩类型、如何缓存的页面、设置的cookie；\n# 第六步：浏览器渲染页面 浏览器渲染页面针对于前端同学，是必备技能，会牵扯到回流和重绘的问题。\n# 第七步：断开连接（四次挥手） 和三次握手一样，是重要的内容，需要牢固掌握。\n代码随想录的作图：\n# 总结 以上内容为一个框架，之后会更新相关内容的时候会链接到对应帖子。\n","date":"2024-04-04T21:10:10+08:00","permalink":"https://yotom131.github.io/p/%E8%BE%93%E5%85%A5url%E5%B9%B6%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/","title":"输入URL并按下回车之后会发生什么？"},{"content":" # 关键字 在4.2的日志中提及到了const关键字的用法，这篇帖子就想着整理一下其他比较重要的关键字的用法。\n# const # 补充 const关键字主要用于指定变量、指针、引用、成员函数等的性质\n常量变量：声明常量，使常量的值不能被改变。\n指针和引用：声明指向常量的指针，表示指针所指的值是常量，不能通过指针修改；声明常量引用，表示引用的值是常量，不能通过引用修改。\n1 2 const int *ptr = \u0026amp;constantValue;//不能修改*ptr的值 const int \u0026amp;ref = constantValue;//不能修改ref的值 成员函数：声明常量成员函数，表示该函数不会修改对象的成员变量（对于成员变量是非静态的情况）。 常量对象：声明对象为常量，使得对象的成员变量不能被改变。 常引用参数：声明函数参数为常量引用，表示函数不会修改传入的参数。 常量指针参数：声明函数参数为指向常量的指针，表示函数不会通过指针修改传入的数据。 指针常量：const int* d = new int(2) 常量指针：int *const e = new int(2) 左定值，右定向：看const在*的左边还是右边。\n# const与define的区别 define：定义预编译时处理的宏，只是简单的字符串替换，无类型检查，不安全。\n区别：\nconst用于定义常量；而define用于定义宏，而宏也可以用于定义常量。\n当都用于定义常量的时候，它们的区别有：\nconst生效于编译的阶段；define生效于预处理阶段。 const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。 const定义的常量是带类型的；define定义的常量不带类型，因此define定义的常量不利于类型检查。 # const与constexpr const表示“只读”的语义，constexpr表示“常量”的语义。\nconstexpr只能定义编译期常量，而const可以定义编译期常量，也可以定义运行期常量。\n你把一个成员函数标记为constexpr，则顺带也将他标记为了cosnt。\n如果你把一个变量标记为constexpr，同样他是const的。\n但以上两条反过来就并不成立。\n# constexpr变量 复杂系统中很难分辨一个初始值是不是常量表达式。可以将变量声明为constexpr类型，由编译器来验证变量的值是否是一个常量表达式。\n必须使用常量初始化：\n1 2 3 constexpr int n = 20; constexpr int m = n + 1; static constexpr int MOD = 1000000007; 如果constexpr声明中定义了一个指针，constexpr仅对指针有效，对所指对象无关。\n1 2 3 constexpr int *p = nullptr;//常量指针，顶层const const int *q = nullptr;//指向常量的指针，底层const int *const q = nullptr;//顶层const # constexpr函数 constexpr函数是指能用于常量表达式的函数。\n函数的返回类型和所有的形参类型都是字面值类型，函数体有且只有一条return语句。\n1 constexpr int new() {return 42;} 为了可以在编译过程展开，constexpr函数被隐式转换成了内联函数。\nconstexpr和内联函数可以在程序中被多次定义，一般定义在头文件。\n# constexpr构造函数 构造函数不能说const，但字面值常量类的构造函数可以是constexpr。\nconstexpr构造函数必须有个空的函数体，即所有成员变量的初始化都放在初始化列表中。对象调用的成员函数必须使用constexpr修饰。\n# constexpr的优点 为一些不能修改数据提供保障，写成变量则有被意外修改的风险。 有些场景编译器可以在编译期对constexpr的代码进行优化，提高效率。 相比宏来说，没有额外的开销，但更加安全可靠。 # static static关键字主要用于控制变量和函数的生命周期、作用域以及访问权限。\n# 静态变量 在函数内部使用static关键字修饰的变量叫做静态变量。\n静态变量在整个程序的生命周期内存在，不会因为离开作用域而被销毁。\n静态变量默认初始化为0（对于基本数据类型）。\n1 2 3 4 5 void fun(){ static int c = 0;//静态变量 c++; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; } # 静态函数 在类内部使用static关键字修饰的函数是静态函数。\n静态函数属于类而非类的实例，可以通过类名直接调用而无需创建对象。\n静态函数不能访问非静态的成员变量和成员函数。\n1 2 3 4 5 6 class Example{ public: static void fun(){ cout \u0026lt;\u0026lt; \u0026#34;Static function\u0026#34; \u0026lt;\u0026lt; endl; } }; # 静态成员变量 在类中使用static关键字修饰的成员变量是静态成员变量。 所有类的对象共享同一个静态成员变量的副本。 静态成员变量必须在类外部单独定义，以便为其分配存储空间。 1 2 3 4 5 6 7 class Example{ public: static int staticVar;//静态成员变量声明 }; //静态成员变量定义 int Example::staticVar = 0; # 静态局部变量 在函数内部使用static关键字修饰的局部变量是静态局部变量。\n静态局部变量的生命周期延长到整个程序的执行过程，但只在声明他的函数内可见。\n1 2 3 4 5 void examplefun(){ static int localVar = 0;//静态局部变量 localVar++; cout \u0026lt;\u0026lt; \u0026#34;localVar: \u0026#34; \u0026lt;\u0026lt; localVar \u0026lt;\u0026lt; endl; } # inline inline是用于函数定义的关键字，说明该函数是内联函数。\n先将内联函数编译完成生成了函数体直接插入被调用的地方，减少了压栈，跳转和返回的操作，没有普通函数调用时候的额外开销。\n内联函数是一种特殊的函数，会进行类型检查。\n对编译器的一种要求，编译器有可能拒绝这种要求。\n限制：\n不能存在任何形式的循环语句 不能存在过多的条件判断语句 函数体不能过于庞大 内联函数声明必须在调用语句之前 # new和malloc的区别 new内存分配失败的时候，会抛出bac_alloc异常，不返回NULL；malloc分配内存失败时返回NULL。 使用new操作符申请内存分配时无需指定内存块的大小，而malloc则需要显式地指出所需内存的尺寸。 operator new/operator delete可以重载，而malloc/free并不允许重载。 new/delete会调用函数的构造函数/析构函数以完成对象的构造/析构。malloc则不会。 malloc和free是C++/C的标准库函数，new/delete是C++的运算符。 new操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。 # volatile 与const绝对对立的类型修饰符，影响编译器编译结果，用该关键字声明的变量表示随时可能发生变化，与之相关的运算不要进行编译优化。会从内存中重新装载内容，而非直接从寄存器中拷贝内容。\n作用：\n指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值，保证对特殊地址的稳定访问。\n使用场合:\n中断服务程序和cpu相关寄存器的定义\n举例：\n1 for(volatile int i = 0; i \u0026lt; 100000; i++);//空循环，会一直执行不会被优化。 # extern 声明外部变量（在函数或者文件外部定义的全局变量）\n# 总结 以上是一些关于C++中关键字的部分，其中部分是比较重要的东西需要牢牢掌握。\n","date":"2024-04-04T19:59:10+08:00","permalink":"https://yotom131.github.io/p/%E5%85%B3%E9%94%AE%E5%AD%97/","title":"关键字"},{"content":" # 输入输出 C++采用了一个全面的标准库来提供IO机制。\niostream库:包含两个基础类型istream、ostream，分别用来表示输入流和输出流。一个流就是一个字符序列，从IO设备读出或者写入IO设备的。\n“流”（stream）：表达的是，随着时间的推移，字符是顺序生成或消耗的。\n# 标准输入输出对象 标准库定义了4个IO对象。\ncin：发音为see-in，istream类型的对象，称作标准输入。 cout：发音为see-out，ostream类型的对象，称作标准输出。 cerr：发音为see-err，用于输出警告和错误信息，称作标准错误。 clog：发音为see-log，用于输出程序运行时的一般信息。 系统通常将程序和所运行的窗口与这些对象关联起来。因此，读取cin时，数据将从程序正在运行的窗口读入，向cout、cerr、clog写入数据时，将会写到同一个窗口。\n# 向流写入数据 1 std::cout \u0026lt;\u0026lt; \u0026#34;Enter two numbers:\u0026#34; \u0026lt;\u0026lt; std::endl; 这是条语句执行了一个表达式（expression）。C++中表达式会产生一个计算结果，由一个或者多个运算对象和（通常有）一个运算符组成。这条语句中的表达式使用了输出运算符（\u0026laquo;）。\n\u0026laquo;运算符接受两个运算对象：\n左侧的运算对象必须是一个ostream对象。 右侧的运算对象必须是要打印的值。 上方语句中endl是一个被称作**操作符（manipulater）的特殊值。效果是结束当前行，并将与设备关联的缓冲区（buffer）**中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。\n# 命名空间 阅读上方代码时，可能会注意到这里使用了std::cout、std::endl，而不是直接使用cout、endl。前缀std::指出cout、endl是定义在名为std的**命名空间（namespace）**中的。命名空间可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突。标准库定义的所有名字都在命名空间std中。\n但这有个副作用，当使用库中一个名字时，必须显式说明想要使用来自命名空间std中的名字。如std::cout。要通过**作用域运算符（::）**来指出我们想使用定义在命名空间std中的名字cout。相信熟悉C++的朋友已经知道，如果想要避免每次都使用std::cout这样的形式来调用cout，可以在头文件下方使用这样的代码段：\n1 using namespace std; 在有这条代码段后，所有需要声明std::的名字，就可以省略掉这个前缀了。\n# 从流读取数据 读取数据首先需要定义变量（variable）：\n1 int a = 0, b = 0; 然后使用**输入运算符（\u0026raquo;）**和std::cin将输入流中的数据存储在变量中：\n1 std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 输入运算符\u0026raquo;规则与前文提到的输出运算符\u0026laquo;规则相似，这里不过赘述。\n# 注释 c++中注释主要使用两种方法：\n单行注释使用// 多行注释使用/*和*/来完成 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 //这里使用单行注释 /* 这里是多行注释 只需要把内容包含在两个符号之间 */ int a, b;//定义变量a和b。 /* 下方提示用户输入变量a和b的值 并将求和结果输出 */ cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; a+b; # 读取数量不定的输入数据 # 给定输入数据数值n 如果我们给出一组数的具体数目，然后输入这组数，输出他们的和，这是个简单的问题：\n1 2 3 4 5 6 7 8 int sum = 0, n, v; cin \u0026gt;\u0026gt; n;//输入这组数据的具体数目 //通过while循环n次 while(n--){ cin \u0026gt;\u0026gt; v;//每次输入当前的数据 sum += v;//每次累加当前数据 } cout \u0026lt;\u0026lt; sum;//输出结果即可 # 无输入数据的数值 但如果我们不给出这个n，那还有办法可以完成吗？\n1 2 3 int sum = 0, v; while(cin \u0026gt;\u0026gt; v) sum += v;//读取数据到文件尾，计算所有输入值的和 cout \u0026lt;\u0026lt; sum; 这样就可以实现只要不停止输入，就可以累加数值了。\n# 结束输入 需要注意的是，当我们使用一个istream对象作为条件时，效果是检测流的状态。如果流是有效的，那么检测成功，而如果遇到文件结束符（end-of-file），或者遇到一个无效输入的时候（例如不是整数类型），istream对象的状态就会无效，最终退出循环。\n结束键盘输入的方式在不同系统中是不一样的。在Windows中，是Ctrl+Z然后按Enter或者Return。而在UNIX（包括MAC OS X）中，是使用Ctrl+D。\n这一部分是控制输入输出的基础部分，有许多题目中可能会用到，但是在笔者观察下，很多同学是没有刻意去了解这部分内容的，作为C++基础重新巩固的环节，这部分内容必不可少。\n# 文件重定向 当测试程序的时候，反复从键盘输入数据是非常乏味、枯燥的。大多数操作系统支持文件重定向，这种机制允许将标准输入和标准输出与命名文件关联起来：\naddItems \u0026lt;infile \u0026gt;outfile\n假定我们的程序已经编译为addItems.exe的可执行文件（UNIX中是addItems），则上述命令会从一个名为infile的文件中读取数据，并将结果写入一个名为outfile的文件中，两个文件都在当前目录中。\n# 总结 这部分内容主要来源于C++ primer，比较基础，是我重学C++过程中前面的一小块，后面写的帖子应该着重于结合面经和自身缺漏来写。\n","date":"2024-04-04T13:59:10+08:00","permalink":"https://yotom131.github.io/p/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","title":"输入输出"},{"content":" # 4.3 # 今日事项 今天完善了博客的基本框架，根据timi测开三面写了两篇答案博客 收到了腾讯子公司的电话，并添加了微信，但并未了解到具体是哪家，约了4.8下午的面试 腾讯官网的校招也有了进展，被腾讯云部门捞了，约了4.7早上的面试 # 总结 总体而言，今天主要工作是完善了博客功能，并解决了timi测开三面时候的遗留问题。求职过程也多了一分赛道，现在手上有两道面试，都是在清明节后。\n今天下午由于时间过多花在了了解子公司信息的方方面面，下午没有在技术上有所进步，后续要做好改良。\n但总体而言，今天是我求职路上的转折点。一方面是收获了一个HR面，一个初试，让我对于后续求职有了更高的把握；另一方面是我开始了写博客的习惯，之后将技术性学习和日志总结要做到位，相信这样可以改善我的生活习惯，并将其善用于求职方面。\n最后，学校里还有党支部的事务未处理，计划赶在清明节期间处理。清明节的安排是在适当的休息中，进行一些面试方面（八股文、基础、算法）的准备来应对4.7上午的腾讯云面试，另外还需要对目前的腾讯子公司（种种迹象猜测是腾娱互动）进行了解，实习工资可以低一些（如果是在深圳的话，期望能有7k、8k的薪资，最低不能低于5k，房租生活费太贵了），但是这半年的实习期要学到技术，要进步，为后面秋招做好准备。\n","date":"2024-04-03T22:46:46+08:00","permalink":"https://yotom131.github.io/p/2024.4.3/","title":"2024.4.3"},{"content":" # C++内存重叠 内存重叠是指在内存中存在两个或多个区域，他们的地址范围有交叉部分，内存重叠可能会导致程序出现不可预期的行为，腾讯timi测开的三问面试官问到了我这个问题，当时没有回答上，非常的遗憾，现在有机会整理一下，变得更强！\n# 内存重叠的原因 内存重叠的主要原因是指针的使用问题。当使用指针访问内存时，如果指针指向的内存区域与另一个区域有交叉部分，就会产生内存重叠。下图展示了内存拷贝的两种情况：\n第一种情况下，拷贝重叠区域不会出现问题，因为拷贝是一个一个放过去，内容可以正常被拷贝。\n第二种情况下，右边两个字节原有的内容被覆盖了，且没有保存，接下来拷贝的时候已经是被覆盖的内容了。\n举个例子，下面代码片段就会导致内存重叠：\n1 2 3 char str[] = \u0026#34;Hello World\u0026#34;; char* p = str +1; memcpy(p, str, 11); 在上面代码中，定义了字符数组str，并使用p指向str中第二个字符。接着，我们用memcpy函数将str中的11个字符复制到p指向的区域。由于p指向的区域与str有交叉部分，因此就产生了内存重叠。因为memcpy是直接按位复制拷贝，代码如下，所以会遇到情况二，拷贝的是已经被覆盖的内容。\n# 如何避免内存重叠 为了避免内存重叠，尤其要注意：\n尽量避免使用指针，尤其是进行运算和类型转换的时候。 在使用指针时，确保指针指向的内存区域与其他区域没有交叉部分。 在使用安全的内存操作函数，如memcpy_s、memmove等，这些函数可以确保在复制内存是不会产生内存重叠 那memmove如何避免内存重叠的影响呢？以下是memmove的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void *memmove(void *dest, const void *src, size_t n) { char *d = dest; const char *s = src; if(d \u0026lt; s) { while (n--) *d++ = *s++; }else{ //采用倒序拷贝 char *lasts = (char *)s + (n - 1); char *lastd = d + (n - 1); while(n--) *lastd-- = *lasts--; } return dest; } remmove判断如果dest\u0026gt;=src的时候（也就是前面图片的情况2），采用倒序拷贝，避免内容被覆盖导致拷贝不完整的问题。\n原理图如下：\nmemcpy与strcpy都有内存重叠的问题，实际可以根据需要使用memmove\n# 总结 三面时候面试官告诉我这是一道思维题，现在想想也是，只用倒序拷贝就能避免粘贴内容被覆盖。但当时满脑子就是想着怎么避开他，诸如存放在别处再拿回来。笔者当时就走不动道了，现在想想一定给面试官留下了“深刻”的印象吧。以上内容既是逻辑题目，也是基础题目，当时抱着试试的想法是走不通的，还是得深入到位，把基础弄扎实，加油吧。\n","date":"2024-04-03T10:46:10+08:00","permalink":"https://yotom131.github.io/p/c-%E5%86%85%E5%AD%98%E9%87%8D%E5%8F%A0/","title":"C++内存重叠"},{"content":" # Hash 概念：hashing是一个过程，将元素储存的位置转化成一个密码（关键码），这是一个不可逆的过程。在查找的时候每次通过哈希函数得到关键码后可以轻松找到对元素的位置。这样的函数叫做哈希函数，最终构造出的结构叫做哈希表（散列表）。\n# 特性 不可逆：hash存在关键码由多个来源转化而来，无法确定哪个关键码是由哪一个来源转换，所以不可逆。\n运算快：20G高清电影和5K文本文件复杂度相同，运算量都极小。越巧妙的hash函数碰撞越少，空间利用率越高。\n结果均匀：哈希函数计算出来的地址能均匀分布在整个空间中，这是hash函数的设计原则。\n# 常见哈希函数和算法 # 直接定址法： 1 Hash(Key) = A * Key + B 这是最简单的hash函数，直接取直接取关键字本身或者他的线性函数来作为散列地址。\n# 除留余数法： 1 Hash(Key) = Key % capacity 这几乎是最常用的哈希函数，用一个数来对key取模，一般来说capacity的值为容量本身。\n经典应用的哈希算法主要是MD5（128位关键码）、SHA-256（256位关键码）、SHA-512（512位关键码）。\n# hash冲突 # 冲突的由来 由于hash函数输出的关键码位数是固定的，将无线的数据输出为有限的数据，那最终得到的结果一定是有重复的，这种输出的关键码重复的时候，就叫做hash冲突，如下图所示。\n# 解决冲突的方法 解决hash冲突的方法主要是以下：\n# 线性测探法 当发生哈希冲突时，从当前位置开始，依次向后查找下一个空闲位置，直至查遍全表。\n但在使用线性测探法的时候，查找、插入、删除的时间复杂度和哈希表的装载因子成正比。并且冲突如果连在一起，很容易产生堆积，查找时会多次重复比较，大大降低查找效率。\n# 二次探测法 基本思路与线性探测法相同，通过二次函数的规律寻找下一个空闲地址。\n# 双重哈希法 发生哈希冲突时，使用另一个哈希函数计算出下一个空闲位置。以上三种属于开放地址法。\n# 链地址法 在hash值重复的情况下，我们也可以考虑将值用链表表示，这样我们在需要查找数据项的时候只需要在对应链表中搜索即可。HashMap在解决储存对象存在hash冲突的时候就是采用链地址法，将hash值相同的对象以链表形式存储。这是一种封闭地址法。\n# 总结 总体而言，哈希是个不可逆的编码过程，以上是一些基本原理，后面涉及到map、unordered_map、dic等键值对的内容时，不单独写博客，希望哈希就此为止，加油！\n","date":"2024-04-03T08:48:15+08:00","permalink":"https://yotom131.github.io/p/hash/","title":"Hash"},{"content":" # 4.2 # 腾讯测开三面总结： ​\t4.1的面试凉的很透彻，明明就差最后一步了，哎。计算机基础没打牢固，c++基础没有打牢固，从这两方面入手抓吧。\n内存重叠部分请点击此处。\nhash部分请点击此处。\n# C++: # 指针和引用： 1 2 3 4 5 6 7 8 9 10 11 12 13 //定义和声明 //此处是指针 int x = 10; int *ptr = \u0026amp;x; //此处是引用，相当于别称 int y = 20; int \u0026amp;ref = y;//引用相当于别称 //使用和操作 int value = *ptr;//获取指针指向的值 int address = \u0026amp;x;//获取x的地址 int newValue = ref;//获取引用的值 空值和空引用：\n指针可以为空（nullptr）。\n引用则必须在声明时初始化，且不能后续改变引用对象，因此没有空引用的概念。\n可变性：\n指针可以改变指向至不同的内存地址。\n引用一旦被初始化，将一直引用同一个对象，不能改变，值可以跟着引用对象改变。\n用途：\n指针通常用于动态内存分配、数组操作、函数参数传递。\n引用通常用于函数参数传递、操作符重载以及创建别名。\n# 数据类型 整形：short int long和long long\nc++数据长度标准：\nshort至少16位，通常为16位。 int至少和short一样长，通常为32位。 long至少32位，且至少和int一样长，通常为32位。 long long至少64位，且至少和long一样长，通常为64位。 在使用8位字节的系统中，1 byte = 8 bit\n可以根据sizeof()来判断数据类型的长度：\n1 2 cout \u0026lt;\u0026lt; \u0026#34;int is \u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; \u0026#34; bytes. \\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;short is \u0026#34; \u0026lt;\u0026lt; sizeof(short) \u0026lt;\u0026lt; \u0026#34; bytes. \\n\u0026#34;; 头文件climits定义了符号常量：例如INT_MAX代表int最大值，INT_MIN代表int最小值 无符号类型\n不储存负数值的整形，可以增大变量存储的最大值，数据长度一致。\n# 关键字 const关键字\n被const修饰的值不能改变，只读变量。必须在定义的时候就给他赋初值。\n1. 常量指针（底层const）\n定义一个指针，指向一个只读的对象，不能通过常量指针来改变这个对象的值。常量指针强调的是指针所指对象的不可改变性。\n特点：*靠近变量名。\n形式：\nconst 数据类型 *指针变量 = 变量名 数据类型 const *指针变量 = 变量名 例如：\n1 2 3 4 5 6 7 int temp = 10; const int* a = \u0026amp;temp; int const *a = \u0026amp;temp; //更改: *a = 9;//错误：只读对象 temp = 9;//正确 2. 指针常量（顶层const）\n定义一个指针，值只能在定义的时候初始化，其他地方不能改变。强调指针的不可改变性。\n特点：*靠近变量类型。\n形式：\n数据类型 * const 指针变量 = 变量名 例如：\n1 2 3 4 5 6 7 int temp = 10; int temp1 = 12; int* const p = \u0026amp;temp; //更改： p = \u0026amp;temp1;//错误 *p = 9;//正确 ","date":"2024-04-02T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.4.2/","title":"2024.4.2"},{"content":" # 3.26 ​\t今天一早上就收到了面试通过的消息，老实说十分激动，并且很期待下一次面试，但因为基础一般的原因，不是很清楚下次面试还会不会这样了解项目情况而少了解基础，总之都得练练，刷题方面的话，日常做两道题。\n昨天的两道哈希表的题目进行了完成，了解到set的insert插入和count统计，并且知道set是存储唯一值的。 移动0， 卡了一会，正确思路是把非0数挨个移到前面去，面试后面一天要重新复习。 移掉K位数字，没做出来，应该是贪心+单调栈，贪心算法不明白是什么，这是个缺点，今晚尽量明白。 ","date":"2024-03-26T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.3.26/","title":"2024.3.26"},{"content":" # 3.25 ​\t今天早上起来最后学习了一会计算机网络相关的知识，重温了一些算法，我对这些算法的记忆还不够深刻，4月初将迎来蓝桥杯，在那个时候需要一定的功底去发展，最好能打一个国奖，这样子对于之后的应聘应该会有很多帮助。\n​\t下午进行了面试，出人意料的是没有考许多八股文，基本上是我自己在阐述。有问到深度学习、transfomer机制这些东西，这些事面试官比较感兴趣的，但我在过程中的表现只能说比较的浅薄，最后捏了一个会的快排，这个让我看见似乎面试官并不会看到我的桌面，后面如果有问题也许可以使用查的方式去完成。但胜任岗位方面需要了解游戏项目的测试自动化、多注意力机制、transformer这些东西，可能会更加地吸引面试官的注意力，就像他们在招聘的时候写着图像处理原理，计算机图形学相关能力。这次面试一直没通知我过，很有可能是在排序中，我并没有表现得那么出色，如果过了，下轮面试在复习好基础后可以着重去了解测试自动化和多注意力机制这方面的东西，不然口头讲述实在是空白无力，而且后面还要面三次。\n​\t如果没有过的话，一方面来说是一场悲报，因为这次面试并不像常规面试一样，而是着重挑了面试官自己想了解的部分，而这些部分我自己属于半懂不懂的状态。后面的反问环节也没有提前准备，只能说下次好好准备吧，这次没过的话其实并不意外，虽然我自己感觉良好，但事实上并没有给出面试官想要的答案。\n​\t今天再刷两道题，然后结束！明天开始多补补计算机网络和操作系统的知识，以免后面考到了。\n今晚因为打卡睡了一道题目，128.最长连续序列，哈希表来做。 第二题也是同理，找到序列中第一个不重复数字的序号，哈希表，明天弄懂。 ","date":"2024-03-25T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.3.25/","title":"2024.3.25"},{"content":" # 3.24日记 ​\t有一些内容昨天忘了提，首先是hash表查找元素可以通过auto it = hash.find(\u0026ldquo;key\u0026rdquo;)，然后判断it是否是hash.end()来确定是否存在这个键。接着他的遍历方式是for(auto it = hash.bedin(); it!= hash.end(); ++it)，或者for(const auto\u0026amp; pair : myMap) 这样的方式遍历，通过hash-\u0026gt;first, hash-\u0026gt;second这样来访问键值对，通过hash.erase()来删除指定键的元素，通过hash.insert(make_pair(\u0026ldquo;key\u0026rdquo;, val))的方式或者hash.emplace(\u0026ldquo;key\u0026rdquo;, val)的方式来添加元素。\n​\t此外，另一个常用的vector容器，可以用for(int element : vec)这样的方式遍历，也可以用索引值for(size_t i = 0; i \u0026lt; vec.size(); i++)这样的方式来遍历。此外还有迭代器，但那个接触不多，可以先不用。\n今天第一道题目是hash表的延申，字母异位词分组，目前水平还是太低了，借助GPT倒是完成了，我的思路是把相同字母的值用键值对的方式存起来，哪些字母组对应了一些值的数组，最后通过把键值对的值赋值给二维向量解决。继续加油吧。 今天第二道题目是有效的括号，属于栈的应用，题目完美符合栈的特点，粗心的错误是在于stk.push(*it)时候，注意根据类型push不同的符号。 今天上午学习了归并排序，并复习了昨天的一些题目，许多题目才一天就有些生疏不知道如何下手了，需要在学习的同时加强巩固。归并的思路是先递归再合并，合并的时候通过双指针指向两组数据的开头，通过对比大小合并，然后将临时数组的值还给原数组，最终完成算法。 顺着合并的思路下午学习了合并K和升序链表，学到了许多新的知识，比如创建虚拟表头，然后删除等，最后重新学习了下vector的几个成员函数，front(), at(), size(), empty(), back(), begin(), end()。并且接着学习到了可以通过int* arr = new int 这样的形式给指针分配动态内存。最后学习了递归方法，希望能常看看这些题目. 然后是一些DP问题，最少的硬币数目，不同路径，两种dp问题，最优解和计数。 ","date":"2024-03-24T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.3.24/","title":"2024.3.24"},{"content":" # 3.23日记 距离腾讯测试开发岗位还有两天不到的时间，现在内心十分紧张，因为技术栈并不多，项目也并没有很匹配。目前主要要求的三个科目是计算机网络、操作系统、算法与数据结构。\n今天学的内容是：\n快速排序、插入排序、希尔排序。快速排序主要思路是找到一个基准值，将大于他的和小于他的放在值得两边。插入排序就像斗地主一样，从第二张牌开始，每次从右往左跟左边比大小，小就往左边换，直到把最右边的值放在合适的位置。希尔排序主题思路与插入排序是一致的，主要区别在于把值分成了多组，用gap来一组组分好位置，当gap为1时，就是插入排序本身。 二叉树的中序遍历。这是力扣的一道题目。重温了vector的使用，和树的结点构造。大体上了解了构造函数的意义，以及中序遍历两种实现思路：递归和迭代。递归每次把左子放入函数，中间存自身，最后放右子即可。迭代则需要一个栈，用来模拟中序遍历的过程，每次空了，就弹出栈顶，记录值，最后返回值即可。 两数之和。这是力扣100的第一题，可以经典的两轮遍历做出来。也可以用hash表来做，对于每一个数值，通过auto it = hash.find(target - nums[i])，判断it值是否是hash.end()来看是否找到了合适的值。顺带了解了，map是有序的，unordered_map可以是无序的哈希表来使用。 每日一题，力扣2549.统计桌面上不同的数字，这是一个可以用简单枚举法完成的问题，但是因为老是先看答案，我已经丧失了思考的过程，要重新锻炼我的编程能力。学习到通过accumulate函数将vector首位累加，不必再使用for遍历完成。此外这道题侧面告诉我，使用数学公式进行简化会更有效果。只有n==1的情况下输出1，其他情况n-1。 总体来说，欠缺的东西还很多，离测试开发的面试要求可能还达不到，加油变强吧少年。\n","date":"2024-03-23T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.3.23/","title":"2024.3.23"}]
[{"content":" # pytest # 测试用例命名规范 ","date":"2024-04-10T12:50:10+08:00","permalink":"https://yotom131.github.io/p/pytest/","title":"pytest"},{"content":" # 软件测试方法 # 软件测试模型——V模型 ","date":"2024-04-10T12:50:10+08:00","permalink":"https://yotom131.github.io/p/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/","title":"软件测试方法"},{"content":" # 软件生命周期 ","date":"2024-04-09T13:25:10+08:00","permalink":"https://yotom131.github.io/p/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/","title":"软件开发模型"},{"content":" # 测试杂谈 # 测试是什么？ 一般把IT技术流程化的话，人员工作分为三类：开发、测试、运维。\n测试在这个IT技术类中担任的作用就是作为软件质量检测的人员。\n一般可以根据测试水平的高低把工作分为三个层次：\n人工软件测试（主要是功能测试） 自动化测试 测试开发（可能涉及到性能测试） 三个层次越往下的测试工作效率越高，技术门槛也会越高。\n# 软件测试需要的技能 # 软件测试 熟悉软件测试流程、测试设计方法，能够独立进行测试策略以及方案编写 独立设计和执行测试方案和测试用例 了解linux并可以搭建和维护测试环境 掌握自动化测试工具 有较强的沟通表达、独立分析和解决问题的能力 # 自动化测试 了解软件测试理论、测试流程和相关测试方法 能独立制定测试计划、测试用例编写测试报告 熟悉linux环境，能进行shell编程 熟悉python，具备自动化测试框架的设计和独立开发能力 掌握SQL语句 熟悉Appium，selenium，Junit，Tesing等自动化测试框架 熟悉LoadRunner，Jmeter等性能测试工具，能自主设计性能测试场景，分析测试结果 熟悉测试中持续集成的流程，熟练运用Jenkins等工具 熟悉软件研发流程，掌握软件测试理论和方法，有开发测试工具或者编写辅助测试脚本的成功实践 # 测试开发 熟悉Linux/Unix操作系统 熟悉Python、Java、C++/C等任意一门编程语言 熟悉MySQL/SQL Server/PostgreSQL/Oracle任何至少一种数据库 熟悉前端技术，包括HTML(5)/css(3)/JavaScript等，并有相关的项目开发经验或成果 深刻理解web标准，对可用性、可访问性等相关知识有实际的了解 有基于Ajax应用的开发经验，有NodeJS/Java开发经验，或者有移动端开发经验 在web、android、ios，接口等自动化领域有较深的造诣和见解 有相关自动化工具/平台（web/app/api接口/测试相关平台工具）开发经验 了解设计模式、微服务框架等优先 对算法、数据结构、建模有一定了解 ","date":"2024-04-09T12:36:10+08:00","permalink":"https://yotom131.github.io/p/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%9D%82%E8%B0%88/","title":"软件测试杂谈"},{"content":" # 4.8 # 今日事项 腾娱乐互动HR面 调整方向 # 总结 今天和腾讯子公司的HR面试了，初步了解了业务。大多数都是我比较喜欢的一个方向，但唯独薪资福利比较低，家里人担心我过去后还需要他们贴钱实习，非常不放心，害怕我被骗了。\n当然我是想从事游戏方面的，但没有任何补贴+薪资低这一点确实太劝退我了，毕竟我是从北京过去，需要大交通和房租，如果这点无法解决，即使入职了我也会挺后悔吧？\n和HR面试完后提了一下要求，HR人挺好的，但可能是我的要求比较突然，他一时无法给我答复，我也挺焦灼的。\n另一方面，我打算重新规划一下路线，之前是抱着倾向于子公司的决定，但目前看来事情可能黄了（HR最后没回我话)，所以打算从软件测试方面下手，先掌握一些技术再说，不过相逢一场，祝他能找到合适的对象吧（双关，指恋爱和事业）。\n还是尽量能找到一个经济能够独立的实习，不要总是找家里人拿钱，这不是我出来实习的初衷吗？总之还是需要合适地调整方向吧，毕竟大多数人在有限的人生里是做不到事事如意的，我只能说做好一些准备，以应付不如意吧。\n","date":"2024-04-07T23:14:46+08:00","permalink":"https://yotom131.github.io/p/2024.4.8/","title":"2024.4.8"},{"content":" # 4.7 # 今日事项 腾讯云部门测试开发一面 # 总结 今天早上完成了腾讯云部门测试开发一面，下午查看流程的时候已经显示进入了复试，想来是提交面评了，后面应该有机会约面试，很幸运！\n和面试官交流中了解到这个部门是有一些云开发、自动化测试方面的东西，在这方面需要学习一些技能，后面的复试照例应该是总监面试，应该要做好一些准备。\n今天时间上并没有花太多在学习上，主要是在资料的收集，也是时候缓缓目前的状态。但无论如何整个学习的过程还是不能停下，坚持才能胜利。当年红军从江西绕大西南，最后才到延安和中央会和，期间有多少辛苦和努力，如今这些与先人相比哪里能相提并论呢？\n当然，每个时代的人有每个时代的使命，我生在当下也应该为当下时代做出自己的社会价值，加油提升自己吧，不说远方，先让自己能够独当一面，学习技术，能够应付更多的业务和需求。目前一个需要主攻的方向我打算放在golang的云原生部分，先做一个项目出来，在做项目的同时学习golang，为之后的进步做一些铺垫。\n尤其是明天下午两点半的子公司面试，这可能是我事业的起点，要好好准备一下。腾讯云的进程也很快，要具体看看什么时候能约下一面，为此也要做好准备，两手抓才能使自己立于不败之地，加油！\n","date":"2024-04-07T19:23:46+08:00","permalink":"https://yotom131.github.io/p/2024.4.7/","title":"2024.4.7"},{"content":" # 4.6 # 今日事项 梳理了一遍7种排序 对网络编程有了更进一步的了解 配置了golang的环境、系统变量 # 总结 今天梳理了冒泡、选择、插入、希尔、快速、归并、堆共7种排序的算法，算是重新巩固了一下基础。\n网络编程方面则是有了一些新的了解，包括套接字、epoll这些以前未曾了解的东西。也大概分清楚了计算机网络这门课和网络编程不说毫无关系，那也是没啥相关的。\n另一方面呢是关注到golang的应用在大厂中其实还算挺广泛，我没有系统学过C++底层的东西和网络编程，python也只是会应用一些工程上的库，并不算精通，这二者于我而言毫无竞争优势可言。另一方面我的项目总是目标识别方面的，而这个由于YOLO的存在，已经烂大街了。。。所以目前打算用golang开辟一条赛道，做个云方面的项目充实下简历（当然这一切是建立在能够直接入职的情况下）\n关于面试，我其实已经倾向于决定去子公司了，因为这个流程拉的有点长了，从3月初出来准备找实习，到现在已经过去了一个月（虽然只有半个月是真的在找实习）。但马上五一快到了，我比较期待4.8和腾讯HR直接聊聊子公司的待遇，看看能否尽快入职。\n祈祷吧，我相信执掌幸运的女神会再次眷顾我。\n我已准备好抓住这次好运的决心。\n","date":"2024-04-06T22:48:46+08:00","permalink":"https://yotom131.github.io/p/2024.4.6/","title":"2024.4.6"},{"content":" # 排序 排序的算法是在面试中经常提到的，且因为部分排序涉及到常见的数据结构，所以这是求职中必备的内容，这里进行一些梳理。\n# 冒泡排序 # 概念 冒泡排序基本是编程中比较简单的排序，很多初学者第一次接触到的排序算法就是它。\n冒泡排序的思想是重复走访要排序的数列，依次比较两种元素，次序部队则进行交换，一直重复这样的过程，直到没有需要交换的元素。\n# 算法原理 下图是个无序数列：1，5，4，2，6，3。\n按照冒泡排序的思想我们要把相邻的元素两两比较，根据大小来交换元素的位置。\n首先开始第一轮\n比较1和5，1比5小，顺序正确，位置不变 比较5和4，5比4大，顺序错误，交换位置 比较5和2，5比2大，顺序不对，交换位置 依次类推，经过第一轮比较后，6作为最大的元素排在了序列最右侧：\n接着开始第二轮，得到的结果应该是把5放在了6的左侧……\n然后是第三轮，结果是4放在了5的左侧……\n这样以此类推，最后就得到了一个有序的数列：\n# 算法特点 时间复杂度：冒泡排序每一轮要遍历所有需要排序的元素，时间复杂度为O(N^2)。\n空间复杂度：冒泡排序过程中需要一个临时变量进行两两交换，额外空间为1。\n稳定性：冒泡排序在排序过程中，相同元素的前后顺序并不改变，所以是一种稳定的排序。\n# 算法实现 1 2 3 4 5 6 7 8 9 10 11 12 void swap(int *a, int *b){ int t = *a; *a = *b; *b = t; } void bubbleSort(int arr[], int n){ for(int i = 0; i \u0026lt; n-1; i++){ for(int j = 0; j \u0026lt; n-i-1; j++) if(arr[j] \u0026gt; arr[j+1]) swap(arr[j], arr[j+1]); } } # 选择排序 # 概念 选择排序是和冒泡排序一样的简单排序算法，思路与冒泡排序也类似，每轮选择一个最大或者最小的元素放在首位，直到所有的元素排完。\n# 算法原理 与之前一样，下图是个无序数列：1，5，4，2，6，3。\n按照选择排序的思想我们要把最小的元素找到并移至首位。\n首先开始第一轮\n比较1和5，1比5小，最小元素是1\n比较1和4，1比4小，最小元素是1\n……………………………………………\n经过一轮比较后，没有比1小的元素，所以1放在首位，位置不变\n然后开始第二轮\n比较5和4，4比5小，最小元素是4\n比较5和2，2比5小，最小元素是2\n……………………………………………\n经过一轮比较后，发现最小元素是2，比5小，所以交换位置\n这样以此类推，最后得到有序数列：\n# 算法特点 时间复杂度：选择排序每一轮要遍历所有需要排序的元素，共遍历n-1轮，时间复杂度为O(N^2)。\n空间复杂度：选择排序过程中需要一个临时变量进行两两交换，额外空间为1。\n稳定性：选择排序在排序过程中，相同元素的前后顺序有可能会改变，所以是一种不稳定的排序。\n# 算法实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void swap(int *a, int *b){ int t = *a; *a = *b; *b = t; } void selectionSort(int arr[], int n){ for(int i = 0; i \u0026lt; n-1; i++){ int minIndex = i; for(int j = i+1; j \u0026lt; n; j++) if(arr[j] \u0026lt; arr[minIndex]) minIndex = j; if(i != minIndex) swap(arr[i], arr[minIndex]); } } # 插入排序 # 概念 插入排序又称斗地主排序（戏称），是一种我们习惯性上使用，但平时很少察觉的排序。原理是将未排序的数据，挨个插入到有序数列的相应位置。\n# 算法原理 与之前一样，下图是个无序数列：1，5，4，2，6，3。\n按照插入排序的思想我们要找将无序数列插入到有序数列中的相应位置\n首先是第一轮：\r5和1比较，1小于5，无需换位 得到了1、5这个有序数列，接着开始第二轮：\n4和5比较，4小于5，再看有序数列的下一个，和1比较 4和1比较，4大于1，发现4的值在1、5之间 将4和5换位，完成插入 按照这样以此类推，最终得到有序数列：\n# 算法特点 时间复杂度：插入排序要进行n-1轮，每轮对比最坏的情况就是1……n-1全部对比一遍，故时间复杂度为O(N^2)。\n空间复杂度：插入排序过程中需要一个临时变量进行两两交换，额外空间为1。\n稳定性：插入排序将无序数列插入有序数列的过程中，不改变相同元素的前后位置，是一种稳定的排序的算法。\n# 算法实现 1 2 3 4 5 6 7 8 9 10 11 12 void insertSort(int arr[], int n){ for(int i = 0; i \u0026lt; n-1; i++){ int end = i, t = arr[end+1]; while(end\u0026gt;=0){ if(t \u0026lt; arr[end]){ arr[end+1] = arr[end]; end--; }else break; } a[end+1] = t; } } # 希尔排序 # 概念 希尔排序是什么？在我眼中就是分类的插入排序，当然你可以反过来说插入排序是希儿增量为1的希尔排序，他们的主体思路是一致的。\n# 算法原理 这是一个无序数列：1、5、8、4、7、2、6、3，我们要将它按从小到大排序。按照希尔排序的思想，我们先把数列进行分组排序\n首先，我们选择序列长度的一半4，作为增量进行分组\n如果所示，1和7一组，5和2一组，8和6一组，4和3一组，共四组\n然后，我们对每一组进行插入排序，排序后序列如下\n经过这一轮排序，序列有序了很多，接着我们进一步缩小增量，增量缩小为原来的一半，也就是2，再进行分组排序\n如图所示，1、6、7、8一组，2、3、5、4一组，共两组\n我们再对每一组进行插入排序，排序后序列如下\n最后，我们进一步把增量缩小为原来一半，也就是1，这相当于直接在序列上进行插入排序，排序结果如下\n至此所有的元素都是有序的\n# 算法特点 时间复杂度：\n希尔排序算法利用分组粗调的方式减少了插入排序算法的工作量，使得算法的平均复杂度低于O(N^2)\n但某些极端的情况下，希尔排序算法的时间复杂度仍然是O(N^2)，甚至比插入排序算法更慢\n为了降低希尔排序算法的时间复杂度，提出了更严谨的算法增量\nHibbard增量，序列为：1、3、7、15…，通项公式为2^k-1， 最坏的时间复杂度为O(n^(3/2))\nSedgewick增量，序列为：1、5、19、41、109…，通项公式为 9 * 4^k - 9 * 2^k + 1 或者 4^k - 3 * 2^k + 1，最坏的时间复杂度为O（n^(4/3)）\n空间复杂度：\n希尔排序算法排序过程中需要一个临时变量存储插入元素，所需要的额外空间为1，因此空间复杂度为O(1)\n稳定性：\n希尔排序算法会进行分组排序，在分组排序的过程中有可能改变相同元素的前后位置，因此是一种不稳定的排序算法\n# 算法实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void shellSort(int arr[], int n){ int gap = n; while(gap \u0026gt; 1){ gap /= 2; for(int i = 0; i \u0026lt; n-gap; i++){ int end = i, t = arr[end+gap]; while(end\u0026gt;=0){ if(arr[end]\u0026gt;t){ arr[end+gap] = arr[end]; end -= gap; }else break; } a[end+gap] = t; } } } # 快速排序 # 概念 快速排序（Quick Sort）是从冒泡排序演变而来的，实际上是在冒泡排序基础上的递归分治法。快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。\n# 算法原理 这是一个无序数列：4、5、8、1、7、2、6、3，我们要将它按从小到大排序。按照快速排序的思想，我们先选择一个基准元素，进行排序\n我们选取4为我们的基准元素，并设置基准元素的位置为index，设置两个指针left和right，分别指向最左和最右两个元素\n接着，从right指针开始，把指针所指向的元素和基准元素做比较，如果比基准元素大，则right指针向左移动，如果比基准元素小，则把right所指向的元素填入index中\n3和4比较，3比4小，将3填入index中，原来3的位置成为了新的index，同时left右移一位\n然后，我们切换left指针进行比较，如果left指向的元素小于基准元素，则left指针向右移动，如果元素大于基准元素，则把left指向的元素填入index中\n5和4比较，5比4大，将5填入index中，原来5的位置成为了新的index，同时right左移一位\n接下来，我们再切换到right指针进行比较，6和4比较，6比4大，right指针左移一位\n2和4比较，2比4小，将2填入index中，原来2的位置成为新的index，left右移一位\n随着left右移，right左移，最终left和right重合\n此时，我们将基准元素填入index中，这时，基准元素左边的都比基准元素小，右边的都比基准元素大，这一轮交换结束\n# 算法特点 时间复杂度 快速排序算法在分治法的思想下，原数列在每一轮被拆分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可再分为止，平均情况下需要logn轮，因此快速排序算法的平均时间复杂度是O(nlogn)\n在极端情况下，快速排序算法每一轮只确定基准元素的位置，时间复杂度为O(N^2)\n空间复杂度 快速排序算法排序过程中只是使用数组原本的空间进行排序，因此空间复杂度为O(1)\n稳定性 快速排序算法在排序过程中，可能使相同元素的前后顺序发生改变，所以快速排序是一种不稳定排序算法\n# 算法实现 思路版\n1 2 3 4 5 6 7 8 9 10 11 12 13 void quickSort(int arr[], int l, int r){ if(l \u0026gt;= r) return ; int base = arr[l]; int u = l, v = r; while(u \u0026lt; v){ while(u \u0026lt; v \u0026amp;\u0026amp; arr[v] \u0026gt;= base) v--; arr[u] = arr[v]; while(u \u0026lt; v \u0026amp;\u0026amp; arr[u] \u0026lt;= base) u++; arr[v] = arr[u]; } arr[u] = base; quickSort(arr, l, u-1), quickSort(arr, u+1, r); } 优化版\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void swap(int *a, int *b){ int t = *a; *a = *b; *b = t; } void quickSort(int arr[], int l, int r){ if(l \u0026gt;= r) return; int base = arr[(l+r)/2]; int u = l-1, v = r+1; while(u \u0026lt; v){ u++;while(arr[u] \u0026lt; base); v--;while(arr[v] \u0026gt; base) if(u \u0026lt; v) swap(arr[u], arr[v]); } quickSort(arr, l, v), quickSort(arr, v+1, r); } # 归并排序 # 概念 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法，归并排序对序列的元素进行逐层折半分组，然后从最小分组开始比较排序，合并成一个大的分组，逐层进行，最终所有的元素都是有序的。\n# 算法思路 这是一个无序数列：4、5、8、1、7、2、6、3，我们要将它按从小到大排序。按照归并排序的思想，我们要把序列逐层进行拆分\n拆分如下：\n接着两两有序合并，即可得到有序数列\n# 算法特点 时间复杂度 归并排序算法每次将序列折半分组，共需要logn轮，因此归并排序算法的时间复杂度是O(nlogn)\n空间复杂度 归并排序算法排序过程中需要额外的一个序列去存储排序后的结果，所占空间是n，因此空间复杂度为O(n)\n稳定性 归并排序算法在排序过程中，相同元素的前后顺序并没有改变，所以归并排序是一种稳定排序算法\n# 算法实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void mergeSort(int arr[], int l, int r){ if(l \u0026gt;= r) return; int m = (l+r)/2; mergeSort(arr, l, m), mergeSort(arr, m+1, r); const int d = r-l+1; int t[d], u = l, v = m+1, k = 0; while(u \u0026lt;= m \u0026amp;\u0026amp; v \u0026lt;= r){ if(arr[u] \u0026lt; arr[v]) t[k++] = arr[u++]; else t[k++] = arr[v++]; } while(u\u0026lt;=m)t[k++] = arr[u++]; while(v\u0026lt;=r)t[k++] = arr[v++]; for(u = l, v = 0; u \u0026lt;= r; u++, v++) arr[u] = t[v]; } # 堆排序 # 概念 堆排序是利用二叉堆（完全二叉树）的概念来排序的选择排序算法，分为两种：\n升序排序：利用最大堆进行排序 降序排序：利用最小堆进行排序 # 算法原理 # bilibili视频 # 图文 以最大堆为例进行演示\n首先删除堆顶元素10（即最大元素），然后将3补充到堆顶，删掉的元素10放在原来3的位置。\n根据二叉堆的自我调节，第二大的元素9会成为新的堆顶\n删除元素9，元素8成为最大堆堆顶\n删除元素8，元素7成为最大堆堆顶\n依次删除最大元素，直到所有元素被删除\n此时，被删除的元素组成了一个由小到大的有序数列\n# 算法特点 时间复杂度 下沉调整的时间复杂度等同于堆的高度O(logn)，构建二叉堆执行下沉调整次数是n/2，循环删除进行下沉调整次数是n-1，时间复杂度约为O(nlogn)\n空间复杂度 堆排序算法排序过程中需要一个临时变量进行两两交换，所需要的额外空间为1，因此空间复杂度为O(1)\n稳定性 堆排序算法在排序过程中，相同元素的前后顺序有可能发生改变，所以堆排序是一种不稳定排序算法\n# 算法实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void heapify(std::vector\u0026lt;int\u0026gt;\u0026amp; arr, int n, int i) { int largest = i; int left = 2 * i + 1; int right = 2 * i + 2; if (left \u0026lt; n \u0026amp;\u0026amp; arr[left] \u0026gt; arr[largest]) largest = left; if (right \u0026lt; n \u0026amp;\u0026amp; arr[right] \u0026gt; arr[largest]) largest = right; if (largest != i) { std::swap(arr[i], arr[largest]); heapify(arr, n, largest); } } void heapSort(std::vector\u0026lt;int\u0026gt;\u0026amp; arr) { int n = arr.size(); for (int i = n / 2 - 1; i \u0026gt;= 0; i--) heapify(arr, n, i); for (int i = n - 1; i \u0026gt; 0; i--) { std::swap(arr[0], arr[i]); heapify(arr, i, 0); } } ","date":"2024-04-06T11:52:10+08:00","permalink":"https://yotom131.github.io/p/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A2%B3%E7%90%86/","title":"一些常见排序的梳理"},{"content":" # 4.5 # 今日事项 对网络中DNS部分进行了梳理，重新巩固 解决了一道力扣hot100题目 梳理后台开发的学习路线 # 总结 关于DNS部分，这里主要是为了完善之前URL提问的框架，将DNS在其中起到的作用，向服务器发送请求直到将URL转换成对应的ip地址，这一块给梳理了一道。\n二则是做了一个三数之和的中等题，用暴力解法有些测试样例过不去，然后使用先排序再双指针的思路将时间复杂度从三次方降到了二次方，最终解决。\n观看了一个后台开发的学习路线，结合之前面试官的建议发现自身在基础方面有着严重缺失，并且在前两天过度钻研于C++的语言本身，而非特性和工程。我目前应该从数据结构和网络编程这两块进行一个恶补，这两块是目前欠缺比较多的，尤其是redis、nginx这样一些应用需要了解清楚，不能一头雾水地乱闯了。\n在学习状态方面，我已经确信是由于HR的直接联系，让我学习的意愿下降了不少。毕竟我确实想尝试做游戏开发，但如果薪资没有到位的话那也只能半途放弃。所以应该激励下自己，目前有个好消息是接到了美团4.6早上的笔试通知，今晚就不能熬夜太晚了，后面连续三天都有事情安排的感觉意外有些充实呢。\n别的也不多说，在三面面试官的拷打下也应该知晓自己基础的薄弱了，尤其是网络编程和C++、操作系统的底层方面（尤其是内存）有着太多东西需要去了解了，应该谨记三面面试官的指导，对于我的分析还是一阵见血的。此外可能还需要了解一些设计模式和测试样例，这对我目前找实习会有不小的帮助。\n","date":"2024-04-05T22:31:46+08:00","permalink":"https://yotom131.github.io/p/2024.4.5/","title":"2024.4.5"},{"content":" # 三数之和 这道题我最开始的解法超时了，太暴力了，思绪有点没转过来。\n# 题目链接 15. 三数之和 - 力扣（LeetCode）\n# 解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { set\u0026lt;multiset\u0026lt;int\u0026gt;\u0026gt; res; for(int i = 0; i \u0026lt; nums.size()-2; i++) { for(int j = i+1; j \u0026lt; nums.size()-1; j++){ for(int k = j+1; k \u0026lt; nums.size(); k++){ if(nums[i] + nums[j] + nums[k] == 0){ multiset\u0026lt;int\u0026gt; tmp = {nums[i], nums[j], nums[k]}; res.insert(tmp); } } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; for(auto i: res){ vector\u0026lt;int\u0026gt; t(i.begin(), i.end()); ans.push_back(t); } return ans; } }; # 思路 没有想太多，看见组不能重复就想到了set和multiset（可以重复的set）。\nmultiset可以实现排序，然后再利用set去掉重复的，就可以输出答案。\n找到目标值的思路也很暴力，三层循环找，然后条件判断存入即可。\n最后来一层转换，实现vector\u0026lt;vector\u0026gt;形式的输出。\n但这个代码只能通过部分测试样例，时间复杂度还有待优化。\n# 优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(nums.begin(), nums.end()); for(int i = 0; i \u0026lt; nums.size(); i++){ if(i \u0026gt; 0 \u0026amp;\u0026amp; nums[i]==nums[i-1]) continue; int tar = -nums[i]; int l = i+1, r = nums.size()-1; while(l\u0026lt;r){ if(nums[l]+nums[r] == tar) { res.push_back({nums[i], nums[l], nums[r]}); while(l\u0026lt;r \u0026amp;\u0026amp; nums[l] == nums[l+1]) l++; while(l\u0026lt;r \u0026amp;\u0026amp; nums[r] == nums[r-1]) r--; l++; r--; }else if(nums[l]+nums[r] \u0026gt; tar) r--; else l++; } } return res; } }; 这个思路是经典双指针算法。\n优化主要有三个重点\n把数列排序，这样子可以帮助我们方便操纵指针指向的数应该变大还是变小。 使用双指针。 去重处理，i、r、l各个位置的值与上一次相同的时候应该跳过。 经过以上处理，AC拿下。\n","date":"2024-04-05T14:56:10+08:00","permalink":"https://yotom131.github.io/p/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","title":"15.三数之和"},{"content":" # DNS # DNS是什么？ DNS(Domain Name System)是一种用于将域名（例如www.yotom.site）转换为IP地址（例如192.168.1.1）的分布式系统。\n在互联网上，计算机和其他网络设备使用IP地址来互相识别和通信。然而，IP地址是一串数字，不太方便人们的使用和记忆，所以就使用了域名来替代复杂的IP地址。\n# DNS服务器为什么不采用集中式？ # 单点故障 如果DNS服务器崩溃，那么整个网络随之瘫痪。通信容量，单个DNS服务器不得不处理所有的DNS查询，这种查询级别可能是上百万上千万级别，一台服务器很难满足。\n# 远距离集中式数据库 单个DNS服务器不可能邻近所有的用户，假设在美国的DNS服务器不可能临近让澳大利亚的查询使用，其中查询请求势必会经过低俗和拥堵的链路，造成严重的时延。\n# 维护 维护成本巨大，而且还需要频繁更新。\n# 域名的层级关系 DNS中的域名都是用句点来分隔开的，比如www.yotom.site，这里的句点代表了不同层次的界限。\n在域名中，越往右的位置表示其层级越高。\n---\r# DNS解析过程 先查询浏览器缓存是否有域名对应的IP地址。 如果浏览器缓存中没有，会去计算机本地的Host文件中查询是否有对应的缓存。 如果Host文件中也没有，则会向本地DNS服务器（这通常由你的互联网服务提供商（ISP）提供，比如中国移动、联通、电信）发送一个DNS查询请求。 如果本地DNS解析器有该域名的ip地址，就会直接返回。如果没有缓存该域名的解析记录，他会向根DNS服务器发出查询请求。根DNS服务器并不负责解析域名，但他能告诉本地DNS解析器应该向哪个顶级域（.com/.net/.org）的DNS服务器继续查询。 本地DNS解析器接着向指定的顶级域名DNS服务器发出查询请求。顶级域DNS服务器也不负责具体的域名解析，但他能告诉本地DNS解析器应该往哪个权威DNS服务器查询下一步的信息。 本地DNS解析器最后向权威DNS服务器发送查询请求。权威DNS服务器是负责存储特定域名和IP地址映射的服务器。当权威DNS服务器收到查询请求时，他会查询“example.com”域名对应的IP地址，并将结果返回给本地DNS解析器。 本地DNS解析器将收到的IP地址返回给浏览器，并且还会将域名解析结果缓存在本地，以便于下次访问时更快地响应。 浏览器发起连接：本地DNS解析器已经将IP地址返回给您的计算机，您的浏览器可以使用该IP地址与目标服务器建立连接，开始获取网页内容。 # 递归查询和迭代查询 递归查询和迭代查询是在DNS解析过程中用于获取域名信息的两种不同方法。\n# 递归查询 在递归查询中，DNS客户端（通常是本地DNS解析器）向上层DNS服务器（如根域名服务器、顶级域名服务器）发送查询请求，并要求这些服务器直接提供完整的解析结果。递归查询的特点是，DNS客户端只需要发送一个查询请求，然后等待完整的解析结果。上层DNS服务器会自行查询下一级的服务器，并将最终结果返回给DNS客户端。\n# 迭代查询 在迭代查询中，DNS客户端向上层DNS服务器发起查询请求，但不要求直接提供完整的解析结果。相反，DNS客户端只是询问上层服务器一个更高级的域名服务器的地址，然后再自行向那个更高级的服务器发起查询请求，以此类推，直到获取完整的解析结果为止。\n递归查询适合普通用户和客户端，而迭代查询适用于DNS服务器之间的通信。\n","date":"2024-04-05T13:34:10+08:00","permalink":"https://yotom131.github.io/p/dns/","title":"DNS"},{"content":" # 11.盛最多水的容器 这是一道简单的双指针算法题，力扣上标注了中等难度，我是抱着每日一题的心态来刷的，总体而言比较简单。\n# 题目链接 11. 盛最多水的容器 - 力扣（LeetCode）\n# 解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int ma = 0, d, l, t, s; for(int i = 0; i \u0026lt; height.size()-1; i++){ if(i\u0026gt;0) if(height[i] \u0026lt;= l) continue; for(int j = height.size()-1; j \u0026gt;= i+1; j--){ if(height[j] \u0026lt;= l) continue; d = j-i; l = height[i] \u0026gt; height[j] ? height[j] : height[i]; s = d*l; ma = s \u0026gt; ma ? s : ma; } } return ma; } }; # 思路 看了下大概的题意，只需要找到两根柱子短的那一根与两根柱子之间的长度组成的矩形最大值就OK了。\n所以得到公式：s = d*l，s是面积，d是两者间距离，l是二柱更短的那根。\n于是设立了用来储存最大s的变量ma，只需要指针i、j两头每次移动的时候算出s用来和ma来比较，最后更新ma即可。\n需要注意的问题是，这道题如果直接暴力完成会超时，但我不想在算法层面上优化，于是进行了剪枝，增加了\n1 if(i\u0026gt;0) if(height[i] \u0026lt;= l) continue; 和\n1 if(height[j] \u0026lt;= l) continue; 两个判断的剪枝操作。\n这个剪枝的思路来源于，随着二根柱子的推进，无论谁比之前的那根短柱短，那都不可能面积更大。因为d也在减小，所以只用计算新柱子大于l的情况。\n# 优化 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int i = 0, j = height.size() - 1, res = 0; while(i \u0026lt; j) { res = height[i] \u0026lt; height[j] ? max(res, (j - i) * height[i++]): max(res, (j - i) * height[j--]); } return res; } }; 作者：Krahets\n链接：点此跳转\n这个优化思路来源于力扣上其他佬的题解，是纯正的双指针，比我写的简洁很多，并且少了层循环，是一种非常高效的思路。但需要求证：只移动短柱，面积可能增大；移动长柱，面积一定减小这一结论。\n","date":"2024-04-04T22:35:10+08:00","permalink":"https://yotom131.github.io/p/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","title":"11.盛最多水的容器"},{"content":" # 4.4 # 今日事项 重新翻阅C++primer，主要是输入输出的部分，巩固基础 对于C++八股文中的关键字部分，做了许多补充，主要是const、static等等 借助一道常见的面试题，梳理了计算机网络面试题目框架 # 总结 总体而言，今天的三个部分都比较基础，内容并不算多，但也需要消化。可能是因为清明节到了，我显得比较怠惰，一天下来大多数时间用来研究这个腾讯子公司的方方面面去了，毕竟下周一就要和HR面试了。不是很清楚是不是这一面就可以确定入职，如果是的话那就是足够幸运。\n今天问了下后面的流程，HR只告诉我上海和深圳的工作地点，都不是在很好的地方，但开发游戏是我很心动的领域。如果能够HR一面就拿到offer，只要薪资不要太低，能承担起我的房租和日常开销，并可能存下一笔钱，那我将光速入职hhh\n总体而言，可能是因为HR直接加我微信了，我没有很大的心思花大量时间看八股文和刷题了，当然也可能是因为清明假期有点心不在焉。但总之如果后面不止HR这一面的话我应该会吃大亏，还是应该适当准备一下腾讯云部门的面试，虽然听说HC好像不多了，不知道我还有没有机会（但真的很想从事游戏方面）。祈祷一下吧，只要待遇还可以，我光速入职！咏鹅十遍！\n","date":"2024-04-04T21:46:46+08:00","permalink":"https://yotom131.github.io/p/2024.4.4/","title":"2024.4.4"},{"content":" # 输入URL并按下回车之后会发生什么？ 这是一道超高频的面试题，可以从这道面试题延伸到计算机网络相关的很多问题。\n# 第一步：输入URL并解析 输入URL后，浏览器会解析出协议、主机、端口、路径等信息，并构建一个HTTP请求（浏览器会根据请求头判断是否有HTTP缓存，并根据是否有缓存来决定是从服务器获取资源还是使用缓存资源）\n这里可以引申到URL的组成部分。\n# 第二步：DNS域名解析 在发送HTTP请求之前，浏览器需要知道想要访问网页（url）对应的IP地址，这就需要DNS域名解析，来将域名解析成对应的IP地址。\nDNS相关内容\n# 第三步：建立起TCP连接（三次握手） 客户端和服务器之间进行HTTP请求和HTTP响应过程中，需要建立起TCP连接，TCP连接需要进行三次握手（后续给出相关内容地址）\n这里是重中之重，可以延伸很多问题：为什么不是两次？不是四次？如果第一次握手丢失了会怎么样？三次握手的过程可以携带数据吗？\n# 第四步：浏览器发送HTTP/HTTPS请求到web服务器 这一步也可以延伸到HTTP/HTTPS的区别？请求的方式？请求的状态码？等等相关内容\n# 第五步：服务器处理HTTP请求并返回HTTP报文 HTTP响应报文和状态码也是常考内容\n服务器会接受请求，将其传递给请求处理程序并发送HTTP相应，一般响应报文包含：请求的网页以及状态码、压缩类型、如何缓存的页面、设置的cookie；\n# 第六步：浏览器渲染页面 浏览器渲染页面针对于前端同学，是必备技能，会牵扯到回流和重绘的问题。\n# 第七步：断开连接（四次挥手） 和三次握手一样，是重要的内容，需要牢固掌握。\n代码随想录的作图：\n# 总结 以上内容为一个框架，之后会更新相关内容的时候会链接到对应帖子。\n","date":"2024-04-04T21:10:10+08:00","permalink":"https://yotom131.github.io/p/%E8%BE%93%E5%85%A5url%E5%B9%B6%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/","title":"输入URL并按下回车之后会发生什么？"},{"content":" # 关键字 在4.2的日志中提及到了const关键字的用法，这篇帖子就想着整理一下其他比较重要的关键字的用法。\n# const # 补充 const关键字主要用于指定变量、指针、引用、成员函数等的性质\n常量变量：声明常量，使常量的值不能被改变。\n指针和引用：声明指向常量的指针，表示指针所指的值是常量，不能通过指针修改；声明常量引用，表示引用的值是常量，不能通过引用修改。\n1 2 const int *ptr = \u0026amp;constantValue;//不能修改*ptr的值 const int \u0026amp;ref = constantValue;//不能修改ref的值 成员函数：声明常量成员函数，表示该函数不会修改对象的成员变量（对于成员变量是非静态的情况）。 常量对象：声明对象为常量，使得对象的成员变量不能被改变。 常引用参数：声明函数参数为常量引用，表示函数不会修改传入的参数。 常量指针参数：声明函数参数为指向常量的指针，表示函数不会通过指针修改传入的数据。 指针常量：const int* d = new int(2) 常量指针：int *const e = new int(2) 左定值，右定向：看const在*的左边还是右边。\n# const与define的区别 define：定义预编译时处理的宏，只是简单的字符串替换，无类型检查，不安全。\n区别：\nconst用于定义常量；而define用于定义宏，而宏也可以用于定义常量。\n当都用于定义常量的时候，它们的区别有：\nconst生效于编译的阶段；define生效于预处理阶段。 const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。 const定义的常量是带类型的；define定义的常量不带类型，因此define定义的常量不利于类型检查。 # const与constexpr const表示“只读”的语义，constexpr表示“常量”的语义。\nconstexpr只能定义编译期常量，而const可以定义编译期常量，也可以定义运行期常量。\n你把一个成员函数标记为constexpr，则顺带也将他标记为了cosnt。\n如果你把一个变量标记为constexpr，同样他是const的。\n但以上两条反过来就并不成立。\n# constexpr变量 复杂系统中很难分辨一个初始值是不是常量表达式。可以将变量声明为constexpr类型，由编译器来验证变量的值是否是一个常量表达式。\n必须使用常量初始化：\n1 2 3 constexpr int n = 20; constexpr int m = n + 1; static constexpr int MOD = 1000000007; 如果constexpr声明中定义了一个指针，constexpr仅对指针有效，对所指对象无关。\n1 2 3 constexpr int *p = nullptr;//常量指针，顶层const const int *q = nullptr;//指向常量的指针，底层const int *const q = nullptr;//顶层const # constexpr函数 constexpr函数是指能用于常量表达式的函数。\n函数的返回类型和所有的形参类型都是字面值类型，函数体有且只有一条return语句。\n1 constexpr int new() {return 42;} 为了可以在编译过程展开，constexpr函数被隐式转换成了内联函数。\nconstexpr和内联函数可以在程序中被多次定义，一般定义在头文件。\n# constexpr构造函数 构造函数不能说const，但字面值常量类的构造函数可以是constexpr。\nconstexpr构造函数必须有个空的函数体，即所有成员变量的初始化都放在初始化列表中。对象调用的成员函数必须使用constexpr修饰。\n# constexpr的优点 为一些不能修改数据提供保障，写成变量则有被意外修改的风险。 有些场景编译器可以在编译期对constexpr的代码进行优化，提高效率。 相比宏来说，没有额外的开销，但更加安全可靠。 # static static关键字主要用于控制变量和函数的生命周期、作用域以及访问权限。\n# 静态变量 在函数内部使用static关键字修饰的变量叫做静态变量。\n静态变量在整个程序的生命周期内存在，不会因为离开作用域而被销毁。\n静态变量默认初始化为0（对于基本数据类型）。\n1 2 3 4 5 void fun(){ static int c = 0;//静态变量 c++; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; } # 静态函数 在类内部使用static关键字修饰的函数是静态函数。\n静态函数属于类而非类的实例，可以通过类名直接调用而无需创建对象。\n静态函数不能访问非静态的成员变量和成员函数。\n1 2 3 4 5 6 class Example{ public: static void fun(){ cout \u0026lt;\u0026lt; \u0026#34;Static function\u0026#34; \u0026lt;\u0026lt; endl; } }; # 静态成员变量 在类中使用static关键字修饰的成员变量是静态成员变量。 所有类的对象共享同一个静态成员变量的副本。 静态成员变量必须在类外部单独定义，以便为其分配存储空间。 1 2 3 4 5 6 7 class Example{ public: static int staticVar;//静态成员变量声明 }; //静态成员变量定义 int Example::staticVar = 0; # 静态局部变量 在函数内部使用static关键字修饰的局部变量是静态局部变量。\n静态局部变量的生命周期延长到整个程序的执行过程，但只在声明他的函数内可见。\n1 2 3 4 5 void examplefun(){ static int localVar = 0;//静态局部变量 localVar++; cout \u0026lt;\u0026lt; \u0026#34;localVar: \u0026#34; \u0026lt;\u0026lt; localVar \u0026lt;\u0026lt; endl; } # inline inline是用于函数定义的关键字，说明该函数是内联函数。\n先将内联函数编译完成生成了函数体直接插入被调用的地方，减少了压栈，跳转和返回的操作，没有普通函数调用时候的额外开销。\n内联函数是一种特殊的函数，会进行类型检查。\n对编译器的一种要求，编译器有可能拒绝这种要求。\n限制：\n不能存在任何形式的循环语句 不能存在过多的条件判断语句 函数体不能过于庞大 内联函数声明必须在调用语句之前 # new和malloc的区别 new内存分配失败的时候，会抛出bac_alloc异常，不返回NULL；malloc分配内存失败时返回NULL。 使用new操作符申请内存分配时无需指定内存块的大小，而malloc则需要显式地指出所需内存的尺寸。 operator new/operator delete可以重载，而malloc/free并不允许重载。 new/delete会调用函数的构造函数/析构函数以完成对象的构造/析构。malloc则不会。 malloc和free是C++/C的标准库函数，new/delete是C++的运算符。 new操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。 # volatile 与const绝对对立的类型修饰符，影响编译器编译结果，用该关键字声明的变量表示随时可能发生变化，与之相关的运算不要进行编译优化。会从内存中重新装载内容，而非直接从寄存器中拷贝内容。\n作用：\n指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值，保证对特殊地址的稳定访问。\n使用场合:\n中断服务程序和cpu相关寄存器的定义\n举例：\n1 for(volatile int i = 0; i \u0026lt; 100000; i++);//空循环，会一直执行不会被优化。 # extern 声明外部变量（在函数或者文件外部定义的全局变量）\n# 总结 以上是一些关于C++中关键字的部分，其中部分是比较重要的东西需要牢牢掌握。\n","date":"2024-04-04T19:59:10+08:00","permalink":"https://yotom131.github.io/p/%E5%85%B3%E9%94%AE%E5%AD%97/","title":"关键字"},{"content":" # 输入输出 C++采用了一个全面的标准库来提供IO机制。\niostream库:包含两个基础类型istream、ostream，分别用来表示输入流和输出流。一个流就是一个字符序列，从IO设备读出或者写入IO设备的。\n“流”（stream）：表达的是，随着时间的推移，字符是顺序生成或消耗的。\n# 标准输入输出对象 标准库定义了4个IO对象。\ncin：发音为see-in，istream类型的对象，称作标准输入。 cout：发音为see-out，ostream类型的对象，称作标准输出。 cerr：发音为see-err，用于输出警告和错误信息，称作标准错误。 clog：发音为see-log，用于输出程序运行时的一般信息。 系统通常将程序和所运行的窗口与这些对象关联起来。因此，读取cin时，数据将从程序正在运行的窗口读入，向cout、cerr、clog写入数据时，将会写到同一个窗口。\n# 向流写入数据 1 std::cout \u0026lt;\u0026lt; \u0026#34;Enter two numbers:\u0026#34; \u0026lt;\u0026lt; std::endl; 这是条语句执行了一个表达式（expression）。C++中表达式会产生一个计算结果，由一个或者多个运算对象和（通常有）一个运算符组成。这条语句中的表达式使用了输出运算符（\u0026laquo;）。\n\u0026laquo;运算符接受两个运算对象：\n左侧的运算对象必须是一个ostream对象。 右侧的运算对象必须是要打印的值。 上方语句中endl是一个被称作**操作符（manipulater）的特殊值。效果是结束当前行，并将与设备关联的缓冲区（buffer）**中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。\n# 命名空间 阅读上方代码时，可能会注意到这里使用了std::cout、std::endl，而不是直接使用cout、endl。前缀std::指出cout、endl是定义在名为std的**命名空间（namespace）**中的。命名空间可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突。标准库定义的所有名字都在命名空间std中。\n但这有个副作用，当使用库中一个名字时，必须显式说明想要使用来自命名空间std中的名字。如std::cout。要通过**作用域运算符（::）**来指出我们想使用定义在命名空间std中的名字cout。相信熟悉C++的朋友已经知道，如果想要避免每次都使用std::cout这样的形式来调用cout，可以在头文件下方使用这样的代码段：\n1 using namespace std; 在有这条代码段后，所有需要声明std::的名字，就可以省略掉这个前缀了。\n# 从流读取数据 读取数据首先需要定义变量（variable）：\n1 int a = 0, b = 0; 然后使用**输入运算符（\u0026raquo;）**和std::cin将输入流中的数据存储在变量中：\n1 std::cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; 输入运算符\u0026raquo;规则与前文提到的输出运算符\u0026laquo;规则相似，这里不过赘述。\n# 注释 c++中注释主要使用两种方法：\n单行注释使用// 多行注释使用/*和*/来完成 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 //这里使用单行注释 /* 这里是多行注释 只需要把内容包含在两个符号之间 */ int a, b;//定义变量a和b。 /* 下方提示用户输入变量a和b的值 并将求和结果输出 */ cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; a+b; # 读取数量不定的输入数据 # 给定输入数据数值n 如果我们给出一组数的具体数目，然后输入这组数，输出他们的和，这是个简单的问题：\n1 2 3 4 5 6 7 8 int sum = 0, n, v; cin \u0026gt;\u0026gt; n;//输入这组数据的具体数目 //通过while循环n次 while(n--){ cin \u0026gt;\u0026gt; v;//每次输入当前的数据 sum += v;//每次累加当前数据 } cout \u0026lt;\u0026lt; sum;//输出结果即可 # 无输入数据的数值 但如果我们不给出这个n，那还有办法可以完成吗？\n1 2 3 int sum = 0, v; while(cin \u0026gt;\u0026gt; v) sum += v;//读取数据到文件尾，计算所有输入值的和 cout \u0026lt;\u0026lt; sum; 这样就可以实现只要不停止输入，就可以累加数值了。\n# 结束输入 需要注意的是，当我们使用一个istream对象作为条件时，效果是检测流的状态。如果流是有效的，那么检测成功，而如果遇到文件结束符（end-of-file），或者遇到一个无效输入的时候（例如不是整数类型），istream对象的状态就会无效，最终退出循环。\n结束键盘输入的方式在不同系统中是不一样的。在Windows中，是Ctrl+Z然后按Enter或者Return。而在UNIX（包括MAC OS X）中，是使用Ctrl+D。\n这一部分是控制输入输出的基础部分，有许多题目中可能会用到，但是在笔者观察下，很多同学是没有刻意去了解这部分内容的，作为C++基础重新巩固的环节，这部分内容必不可少。\n# 文件重定向 当测试程序的时候，反复从键盘输入数据是非常乏味、枯燥的。大多数操作系统支持文件重定向，这种机制允许将标准输入和标准输出与命名文件关联起来：\naddItems \u0026lt;infile \u0026gt;outfile\n假定我们的程序已经编译为addItems.exe的可执行文件（UNIX中是addItems），则上述命令会从一个名为infile的文件中读取数据，并将结果写入一个名为outfile的文件中，两个文件都在当前目录中。\n# 总结 这部分内容主要来源于C++ primer，比较基础，是我重学C++过程中前面的一小块，后面写的帖子应该着重于结合面经和自身缺漏来写。\n","date":"2024-04-04T13:59:10+08:00","permalink":"https://yotom131.github.io/p/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","title":"输入输出"},{"content":" # 4.3 # 今日事项 今天完善了博客的基本框架，根据timi测开三面写了两篇答案博客 收到了腾讯子公司的电话，并添加了微信，但并未了解到具体是哪家，约了4.8下午的面试 腾讯官网的校招也有了进展，被腾讯云部门捞了，约了4.7早上的面试 # 总结 总体而言，今天主要工作是完善了博客功能，并解决了timi测开三面时候的遗留问题。求职过程也多了一分赛道，现在手上有两道面试，都是在清明节后。\n今天下午由于时间过多花在了了解子公司信息的方方面面，下午没有在技术上有所进步，后续要做好改良。\n但总体而言，今天是我求职路上的转折点。一方面是收获了一个HR面，一个初试，让我对于后续求职有了更高的把握；另一方面是我开始了写博客的习惯，之后将技术性学习和日志总结要做到位，相信这样可以改善我的生活习惯，并将其善用于求职方面。\n最后，学校里还有党支部的事务未处理，计划赶在清明节期间处理。清明节的安排是在适当的休息中，进行一些面试方面（八股文、基础、算法）的准备来应对4.7上午的腾讯云面试，另外还需要对目前的腾讯子公司（种种迹象猜测是腾娱互动）进行了解，实习工资可以低一些（如果是在深圳的话，期望能有7k、8k的薪资，最低不能低于5k，房租生活费太贵了），但是这半年的实习期要学到技术，要进步，为后面秋招做好准备。\n","date":"2024-04-03T22:46:46+08:00","permalink":"https://yotom131.github.io/p/2024.4.3/","title":"2024.4.3"},{"content":" # C++内存重叠 内存重叠是指在内存中存在两个或多个区域，他们的地址范围有交叉部分，内存重叠可能会导致程序出现不可预期的行为，腾讯timi测开的三问面试官问到了我这个问题，当时没有回答上，非常的遗憾，现在有机会整理一下，变得更强！\n# 内存重叠的原因 内存重叠的主要原因是指针的使用问题。当使用指针访问内存时，如果指针指向的内存区域与另一个区域有交叉部分，就会产生内存重叠。下图展示了内存拷贝的两种情况：\n第一种情况下，拷贝重叠区域不会出现问题，因为拷贝是一个一个放过去，内容可以正常被拷贝。\n第二种情况下，右边两个字节原有的内容被覆盖了，且没有保存，接下来拷贝的时候已经是被覆盖的内容了。\n举个例子，下面代码片段就会导致内存重叠：\n1 2 3 char str[] = \u0026#34;Hello World\u0026#34;; char* p = str +1; memcpy(p, str, 11); 在上面代码中，定义了字符数组str，并使用p指向str中第二个字符。接着，我们用memcpy函数将str中的11个字符复制到p指向的区域。由于p指向的区域与str有交叉部分，因此就产生了内存重叠。因为memcpy是直接按位复制拷贝，代码如下，所以会遇到情况二，拷贝的是已经被覆盖的内容。\n# 如何避免内存重叠 为了避免内存重叠，尤其要注意：\n尽量避免使用指针，尤其是进行运算和类型转换的时候。 在使用指针时，确保指针指向的内存区域与其他区域没有交叉部分。 在使用安全的内存操作函数，如memcpy_s、memmove等，这些函数可以确保在复制内存是不会产生内存重叠 那memmove如何避免内存重叠的影响呢？以下是memmove的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void *memmove(void *dest, const void *src, size_t n) { char *d = dest; const char *s = src; if(d \u0026lt; s) { while (n--) *d++ = *s++; }else{ //采用倒序拷贝 char *lasts = (char *)s + (n - 1); char *lastd = d + (n - 1); while(n--) *lastd-- = *lasts--; } return dest; } remmove判断如果dest\u0026gt;=src的时候（也就是前面图片的情况2），采用倒序拷贝，避免内容被覆盖导致拷贝不完整的问题。\n原理图如下：\nmemcpy与strcpy都有内存重叠的问题，实际可以根据需要使用memmove\n# 总结 三面时候面试官告诉我这是一道思维题，现在想想也是，只用倒序拷贝就能避免粘贴内容被覆盖。但当时满脑子就是想着怎么避开他，诸如存放在别处再拿回来。笔者当时就走不动道了，现在想想一定给面试官留下了“深刻”的印象吧。以上内容既是逻辑题目，也是基础题目，当时抱着试试的想法是走不通的，还是得深入到位，把基础弄扎实，加油吧。\n","date":"2024-04-03T10:46:10+08:00","permalink":"https://yotom131.github.io/p/c-%E5%86%85%E5%AD%98%E9%87%8D%E5%8F%A0/","title":"C++内存重叠"},{"content":" # Hash 概念：hashing是一个过程，将元素储存的位置转化成一个密码（关键码），这是一个不可逆的过程。在查找的时候每次通过哈希函数得到关键码后可以轻松找到对元素的位置。这样的函数叫做哈希函数，最终构造出的结构叫做哈希表（散列表）。\n# 特性 不可逆：hash存在关键码由多个来源转化而来，无法确定哪个关键码是由哪一个来源转换，所以不可逆。\n运算快：20G高清电影和5K文本文件复杂度相同，运算量都极小。越巧妙的hash函数碰撞越少，空间利用率越高。\n结果均匀：哈希函数计算出来的地址能均匀分布在整个空间中，这是hash函数的设计原则。\n# 常见哈希函数和算法 # 直接定址法： 1 Hash(Key) = A * Key + B 这是最简单的hash函数，直接取直接取关键字本身或者他的线性函数来作为散列地址。\n# 除留余数法： 1 Hash(Key) = Key % capacity 这几乎是最常用的哈希函数，用一个数来对key取模，一般来说capacity的值为容量本身。\n经典应用的哈希算法主要是MD5（128位关键码）、SHA-256（256位关键码）、SHA-512（512位关键码）。\n# hash冲突 # 冲突的由来 由于hash函数输出的关键码位数是固定的，将无线的数据输出为有限的数据，那最终得到的结果一定是有重复的，这种输出的关键码重复的时候，就叫做hash冲突，如下图所示。\n# 解决冲突的方法 解决hash冲突的方法主要是以下：\n# 线性测探法 当发生哈希冲突时，从当前位置开始，依次向后查找下一个空闲位置，直至查遍全表。\n但在使用线性测探法的时候，查找、插入、删除的时间复杂度和哈希表的装载因子成正比。并且冲突如果连在一起，很容易产生堆积，查找时会多次重复比较，大大降低查找效率。\n# 二次探测法 基本思路与线性探测法相同，通过二次函数的规律寻找下一个空闲地址。\n# 双重哈希法 发生哈希冲突时，使用另一个哈希函数计算出下一个空闲位置。以上三种属于开放地址法。\n# 链地址法 在hash值重复的情况下，我们也可以考虑将值用链表表示，这样我们在需要查找数据项的时候只需要在对应链表中搜索即可。HashMap在解决储存对象存在hash冲突的时候就是采用链地址法，将hash值相同的对象以链表形式存储。这是一种封闭地址法。\n# 总结 总体而言，哈希是个不可逆的编码过程，以上是一些基本原理，后面涉及到map、unordered_map、dic等键值对的内容时，不单独写博客，希望哈希就此为止，加油！\n","date":"2024-04-03T08:48:15+08:00","permalink":"https://yotom131.github.io/p/hash/","title":"Hash"},{"content":" # 4.2 # 腾讯测开三面总结： ​\t4.1的面试凉的很透彻，明明就差最后一步了，哎。计算机基础没打牢固，c++基础没有打牢固，从这两方面入手抓吧。\n内存重叠部分请点击此处。\nhash部分请点击此处。\n# C++: # 指针和引用： 1 2 3 4 5 6 7 8 9 10 11 12 13 //定义和声明 //此处是指针 int x = 10; int *ptr = \u0026amp;x; //此处是引用，相当于别称 int y = 20; int \u0026amp;ref = y;//引用相当于别称 //使用和操作 int value = *ptr;//获取指针指向的值 int address = \u0026amp;x;//获取x的地址 int newValue = ref;//获取引用的值 空值和空引用：\n指针可以为空（nullptr）。\n引用则必须在声明时初始化，且不能后续改变引用对象，因此没有空引用的概念。\n可变性：\n指针可以改变指向至不同的内存地址。\n引用一旦被初始化，将一直引用同一个对象，不能改变，值可以跟着引用对象改变。\n用途：\n指针通常用于动态内存分配、数组操作、函数参数传递。\n引用通常用于函数参数传递、操作符重载以及创建别名。\n# 数据类型 整形：short int long和long long\nc++数据长度标准：\nshort至少16位，通常为16位。 int至少和short一样长，通常为32位。 long至少32位，且至少和int一样长，通常为32位。 long long至少64位，且至少和long一样长，通常为64位。 在使用8位字节的系统中，1 byte = 8 bit\n可以根据sizeof()来判断数据类型的长度：\n1 2 cout \u0026lt;\u0026lt; \u0026#34;int is \u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; \u0026#34; bytes. \\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;short is \u0026#34; \u0026lt;\u0026lt; sizeof(short) \u0026lt;\u0026lt; \u0026#34; bytes. \\n\u0026#34;; 头文件climits定义了符号常量：例如INT_MAX代表int最大值，INT_MIN代表int最小值 无符号类型\n不储存负数值的整形，可以增大变量存储的最大值，数据长度一致。\n# 关键字 const关键字\n被const修饰的值不能改变，只读变量。必须在定义的时候就给他赋初值。\n1. 常量指针（底层const）\n定义一个指针，指向一个只读的对象，不能通过常量指针来改变这个对象的值。常量指针强调的是指针所指对象的不可改变性。\n特点：*靠近变量名。\n形式：\nconst 数据类型 *指针变量 = 变量名 数据类型 const *指针变量 = 变量名 例如：\n1 2 3 4 5 6 7 int temp = 10; const int* a = \u0026amp;temp; int const *a = \u0026amp;temp; //更改: *a = 9;//错误：只读对象 temp = 9;//正确 2. 指针常量（顶层const）\n定义一个指针，值只能在定义的时候初始化，其他地方不能改变。强调指针的不可改变性。\n特点：*靠近变量类型。\n形式：\n数据类型 * const 指针变量 = 变量名 例如：\n1 2 3 4 5 6 7 int temp = 10; int temp1 = 12; int* const p = \u0026amp;temp; //更改： p = \u0026amp;temp1;//错误 *p = 9;//正确 ","date":"2024-04-02T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.4.2/","title":"2024.4.2"},{"content":" # 3.26 ​\t今天一早上就收到了面试通过的消息，老实说十分激动，并且很期待下一次面试，但因为基础一般的原因，不是很清楚下次面试还会不会这样了解项目情况而少了解基础，总之都得练练，刷题方面的话，日常做两道题。\n昨天的两道哈希表的题目进行了完成，了解到set的insert插入和count统计，并且知道set是存储唯一值的。 移动0， 卡了一会，正确思路是把非0数挨个移到前面去，面试后面一天要重新复习。 移掉K位数字，没做出来，应该是贪心+单调栈，贪心算法不明白是什么，这是个缺点，今晚尽量明白。 ","date":"2024-03-26T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.3.26/","title":"2024.3.26"},{"content":" # 3.25 ​\t今天早上起来最后学习了一会计算机网络相关的知识，重温了一些算法，我对这些算法的记忆还不够深刻，4月初将迎来蓝桥杯，在那个时候需要一定的功底去发展，最好能打一个国奖，这样子对于之后的应聘应该会有很多帮助。\n​\t下午进行了面试，出人意料的是没有考许多八股文，基本上是我自己在阐述。有问到深度学习、transfomer机制这些东西，这些事面试官比较感兴趣的，但我在过程中的表现只能说比较的浅薄，最后捏了一个会的快排，这个让我看见似乎面试官并不会看到我的桌面，后面如果有问题也许可以使用查的方式去完成。但胜任岗位方面需要了解游戏项目的测试自动化、多注意力机制、transformer这些东西，可能会更加地吸引面试官的注意力，就像他们在招聘的时候写着图像处理原理，计算机图形学相关能力。这次面试一直没通知我过，很有可能是在排序中，我并没有表现得那么出色，如果过了，下轮面试在复习好基础后可以着重去了解测试自动化和多注意力机制这方面的东西，不然口头讲述实在是空白无力，而且后面还要面三次。\n​\t如果没有过的话，一方面来说是一场悲报，因为这次面试并不像常规面试一样，而是着重挑了面试官自己想了解的部分，而这些部分我自己属于半懂不懂的状态。后面的反问环节也没有提前准备，只能说下次好好准备吧，这次没过的话其实并不意外，虽然我自己感觉良好，但事实上并没有给出面试官想要的答案。\n​\t今天再刷两道题，然后结束！明天开始多补补计算机网络和操作系统的知识，以免后面考到了。\n今晚因为打卡睡了一道题目，128.最长连续序列，哈希表来做。 第二题也是同理，找到序列中第一个不重复数字的序号，哈希表，明天弄懂。 ","date":"2024-03-25T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.3.25/","title":"2024.3.25"},{"content":" # 3.24日记 ​\t有一些内容昨天忘了提，首先是hash表查找元素可以通过auto it = hash.find(\u0026ldquo;key\u0026rdquo;)，然后判断it是否是hash.end()来确定是否存在这个键。接着他的遍历方式是for(auto it = hash.bedin(); it!= hash.end(); ++it)，或者for(const auto\u0026amp; pair : myMap) 这样的方式遍历，通过hash-\u0026gt;first, hash-\u0026gt;second这样来访问键值对，通过hash.erase()来删除指定键的元素，通过hash.insert(make_pair(\u0026ldquo;key\u0026rdquo;, val))的方式或者hash.emplace(\u0026ldquo;key\u0026rdquo;, val)的方式来添加元素。\n​\t此外，另一个常用的vector容器，可以用for(int element : vec)这样的方式遍历，也可以用索引值for(size_t i = 0; i \u0026lt; vec.size(); i++)这样的方式来遍历。此外还有迭代器，但那个接触不多，可以先不用。\n今天第一道题目是hash表的延申，字母异位词分组，目前水平还是太低了，借助GPT倒是完成了，我的思路是把相同字母的值用键值对的方式存起来，哪些字母组对应了一些值的数组，最后通过把键值对的值赋值给二维向量解决。继续加油吧。 今天第二道题目是有效的括号，属于栈的应用，题目完美符合栈的特点，粗心的错误是在于stk.push(*it)时候，注意根据类型push不同的符号。 今天上午学习了归并排序，并复习了昨天的一些题目，许多题目才一天就有些生疏不知道如何下手了，需要在学习的同时加强巩固。归并的思路是先递归再合并，合并的时候通过双指针指向两组数据的开头，通过对比大小合并，然后将临时数组的值还给原数组，最终完成算法。 顺着合并的思路下午学习了合并K和升序链表，学到了许多新的知识，比如创建虚拟表头，然后删除等，最后重新学习了下vector的几个成员函数，front(), at(), size(), empty(), back(), begin(), end()。并且接着学习到了可以通过int* arr = new int 这样的形式给指针分配动态内存。最后学习了递归方法，希望能常看看这些题目. 然后是一些DP问题，最少的硬币数目，不同路径，两种dp问题，最优解和计数。 ","date":"2024-03-24T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.3.24/","title":"2024.3.24"},{"content":" # 3.23日记 距离腾讯测试开发岗位还有两天不到的时间，现在内心十分紧张，因为技术栈并不多，项目也并没有很匹配。目前主要要求的三个科目是计算机网络、操作系统、算法与数据结构。\n今天学的内容是：\n快速排序、插入排序、希尔排序。快速排序主要思路是找到一个基准值，将大于他的和小于他的放在值得两边。插入排序就像斗地主一样，从第二张牌开始，每次从右往左跟左边比大小，小就往左边换，直到把最右边的值放在合适的位置。希尔排序主题思路与插入排序是一致的，主要区别在于把值分成了多组，用gap来一组组分好位置，当gap为1时，就是插入排序本身。 二叉树的中序遍历。这是力扣的一道题目。重温了vector的使用，和树的结点构造。大体上了解了构造函数的意义，以及中序遍历两种实现思路：递归和迭代。递归每次把左子放入函数，中间存自身，最后放右子即可。迭代则需要一个栈，用来模拟中序遍历的过程，每次空了，就弹出栈顶，记录值，最后返回值即可。 两数之和。这是力扣100的第一题，可以经典的两轮遍历做出来。也可以用hash表来做，对于每一个数值，通过auto it = hash.find(target - nums[i])，判断it值是否是hash.end()来看是否找到了合适的值。顺带了解了，map是有序的，unordered_map可以是无序的哈希表来使用。 每日一题，力扣2549.统计桌面上不同的数字，这是一个可以用简单枚举法完成的问题，但是因为老是先看答案，我已经丧失了思考的过程，要重新锻炼我的编程能力。学习到通过accumulate函数将vector首位累加，不必再使用for遍历完成。此外这道题侧面告诉我，使用数学公式进行简化会更有效果。只有n==1的情况下输出1，其他情况n-1。 总体来说，欠缺的东西还很多，离测试开发的面试要求可能还达不到，加油变强吧少年。\n","date":"2024-03-23T14:01:26+08:00","permalink":"https://yotom131.github.io/p/2024.3.23/","title":"2024.3.23"}]
+++
title = 'Hash'
date = 2024-04-03T08:48:15+08:00
draft = false
+++

# Hash

**概念**：hashing是一个过程，将元素储存的位置转化成一个密码（关键码），这是一个不可逆的过程。在查找的时候每次通过哈希函数得到关键码后可以轻松找到对元素的位置。这样的函数叫做**哈希函数**，最终构造出的结构叫做**哈希表（散列表）**。

---

## 特性

+ **不可逆**：hash存在关键码由多个来源转化而来，无法确定哪个关键码是由哪一个来源转换，所以不可逆。

+ **运算快**：20G高清电影和5K文本文件复杂度相同，运算量都极小。越巧妙的hash函数碰撞越少，空间利用率越高。
+ **结果均匀**：哈希函数计算出来的地址能均匀分布在整个空间中，这是hash函数的设计原则。

---

## 常见哈希函数和算法

### 直接定址法：

```c++
Hash(Key) = A * Key + B
```

这是最简单的hash函数，直接取直接取关键字本身或者他的线性函数来作为散列地址。

### 除留余数法：

```c++
Hash(Key) = Key % capacity
```

这几乎是最常用的哈希函数，用一个数来对key取模，一般来说capacity的值为容量本身。

经典应用的哈希算法主要是**MD5（128位关键码）**、**SHA-256（256位关键码）**、**SHA-512（512位关键码）**。

---

## hash冲突

### 冲突的由来

由于hash函数输出的关键码位数是固定的，将无线的数据输出为有限的数据，那最终得到的结果一定是有重复的，这种输出的关键码重复的时候，就叫做**hash冲突**，如下图所示。

<div style="text-align: center;">
    <img src="/img/hash_1.png" alt="哈希冲突" style="max-width: 60%; height: auto;">
</div>

### 解决冲突的方法

解决hash冲突的方法主要是以下：

1. #### 线性测探法

当发生哈希冲突时，从当前位置开始，依次向后查找下一个空闲位置，直至查遍全表。

<div style="text-align: center;">
    <img src="/img/hash_2.png" alt="线性测探法" style="max-width: 60%; height: auto;">
</div>

但在使用线性测探法的时候，查找、插入、删除的时间复杂度和哈希表的装载因子成正比。**并且冲突如果连在一起，很容易产生堆积，查找时会多次重复比较，大大降低查找效率。**

2. #### 二次探测法

基本思路与线性探测法相同，通过二次函数的规律寻找下一个空闲地址。

3. #### 双重哈希法

发生哈希冲突时，使用另一个哈希函数计算出下一个空闲位置。以上三种属于**开放地址法**。

4. #### 链地址法

在hash值重复的情况下，我们也可以考虑将值用链表表示，这样我们在需要查找数据项的时候只需要在对应链表中搜索即可。**HashMap**在解决储存对象存在hash冲突的时候就是采用链地址法，将hash值相同的对象以链表形式存储。这是一种**封闭地址法**。

<div style="text-align: center;">
    <img src="/img/hash_3.png" alt="链地址法" style="max-width: 60%; height: auto;">
</div>

---

## 总结

总体而言，哈希是个不可逆的编码过程，以上是一些基本原理，后面涉及到map、unordered_map、dic等键值对的内容时，不单独写博客，希望哈希就此为止，加油！

---

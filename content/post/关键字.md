+++

title = '关键字'
date = 2024-04-04T19:59:10+08:00
author = "Yotom"
description = "C++中的一些关键字"
tags = [
    "static",
    "inline",
    "new",
    "关键字",

]
categories = [
    "学习记录",
    "C/C++",
]

+++

# 关键字

在4.2的日志中提及到了const关键字的用法，这篇帖子就想着整理一下其他比较重要的关键字的用法。

## const

### 补充

`const`关键字主要用于指定变量、指针、引用、成员函数等的性质

1. 常量变量：声明常量，使常量的值不能被改变。

2. 指针和引用：声明指向常量的指针，表示指针所指的值是常量，不能通过指针修改；声明常量引用，表示引用的值是常量，不能通过引用修改。

```c++
const int *ptr = &constantValue;//不能修改*ptr的值
const int &ref = constantValue;//不能修改ref的值
```

3. 成员函数：声明常量成员函数，表示该函数不会修改对象的成员变量（对于成员变量是非静态的情况）。
4. 常量对象：声明对象为常量，使得对象的成员变量不能被改变。
5. 常引用参数：声明函数参数为常量引用，表示函数不会修改传入的参数。
6. 常量指针参数：声明函数参数为指向常量的指针，表示函数不会通过指针修改传入的数据。
7. 指针常量：`const int* d = new int(2)`
8. 常量指针：`int *const e = new int(2) `

左定值，右定向：看const在*的左边还是右边。

### const与define的区别

**define**：定义预编译时处理的宏，只是简单的字符串替换，无类型检查，不安全。

**区别**：

const用于定义常量；而define用于定义宏，而宏也可以用于定义常量。

当都用于定义常量的时候，它们的区别有：

1. const生效于编译的阶段；define生效于预处理阶段。
2. const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。
3. const定义的常量是带类型的；define定义的常量不带类型，因此define定义的常量不利于类型检查。

### const与constexpr

const表示“只读”的语义，constexpr表示“常量”的语义。

constexpr只能定义编译期常量，而const可以定义编译期常量，也可以定义运行期常量。

+ 你把一个成员函数标记为constexpr，则顺带也将他标记为了cosnt。

+ 如果你把一个变量标记为constexpr，同样他是const的。

但以上两条反过来就并不成立。

### constexpr变量

复杂系统中很难分辨一个初始值是不是常量表达式。可以将变量声明为constexpr类型，由编译器来验证变量的值是否是一个常量表达式。

**必须使用常量初始化：**

```c++
constexpr int n = 20;
constexpr int m = n + 1;
static constexpr int MOD = 1000000007;
```

如果constexpr声明中定义了一个指针，constexpr仅对指针有效，对所指对象无关。

```c++
constexpr int *p = nullptr;//常量指针，顶层const
const int *q = nullptr;//指向常量的指针，底层const
int *const q = nullptr;//顶层const
```

### constexpr函数

constexpr函数是指能用于常量表达式的函数。

函数的返回类型和所有的形参类型都是字面值类型，函数体有且只有一条return语句。

```c++
constexpr int new() {return 42;}
```

为了可以在编译过程展开，constexpr函数被隐式转换成了内联函数。

constexpr和内联函数可以在程序中被多次定义，一般定义在头文件。

### constexpr构造函数

构造函数不能说const，但字面值常量类的构造函数可以是constexpr。

constexpr构造函数必须有个空的函数体，即所有成员变量的初始化都放在初始化列表中。对象调用的成员函数必须使用constexpr修饰。

### constexpr的优点

1. 为一些不能修改数据提供保障，写成变量则有被意外修改的风险。
2. 有些场景编译器可以在编译期对constexpr的代码进行优化，提高效率。
3. 相比宏来说，没有额外的开销，但更加安全可靠。

---

## static

`static`关键字主要用于控制变量和函数的生命周期、作用域以及访问权限。

1. ### 静态变量

   + 在函数内部使用`static`关键字修饰的变量叫做静态变量。

   + 静态变量在整个程序的生命周期内存在，不会因为离开作用域而被销毁。

   + 静态变量默认初始化为0（对于基本数据类型）。
```c++
void fun(){
    static int c = 0;//静态变量
    c++;
    cout << c << endl;
} 
```

2. ### 静态函数

   + 在类内部使用`static`关键字修饰的函数是静态函数。

   + 静态函数属于类而非类的实例，可以通过类名直接调用而无需创建对象。

   + 静态函数不能访问非静态的成员变量和成员函数。

```c++
class Example{
public:
    static void fun(){
        cout << "Static function" << endl;
    }
};
```

3. ### 静态成员变量

   + 在类中使用`static`关键字修饰的成员变量是静态成员变量。
   + 所有类的对象共享同一个静态成员变量的副本。
   + 静态成员变量必须在类外部单独定义，以便为其分配存储空间。
```c++
class Example{
public:
    static int staticVar;//静态成员变量声明
};

//静态成员变量定义
int Example::staticVar = 0;
```

4. ### 静态局部变量

   + 在函数内部使用`static`关键字修饰的局部变量是静态局部变量。

   + 静态局部变量的生命周期延长到整个程序的执行过程，但只在声明他的函数内可见。

```C++
void examplefun(){
    static int localVar = 0;//静态局部变量
    localVar++;
    cout << "localVar: " << localVar << endl;
}
```

---

## inline

inline是用于函数定义的关键字，说明该函数是内联函数。

先将内联函数编译完成生成了函数体直接插入被调用的地方，减少了压栈，跳转和返回的操作，没有普通函数调用时候的额外开销。

内联函数是一种特殊的函数，会进行类型检查。

对编译器的一种要求，编译器有可能拒绝这种要求。

**限制**：

1. 不能存在任何形式的循环语句
2. 不能存在过多的条件判断语句
3. 函数体不能过于庞大
4. 内联函数声明必须在调用语句之前

---

## new和malloc的区别

1. new内存分配失败的时候，会抛出bac_alloc异常，不返回NULL；malloc分配内存失败时返回NULL。
2. 使用new操作符申请内存分配时无需指定内存块的大小，而malloc则需要显式地指出所需内存的尺寸。
3. operator new/operator delete可以重载，而malloc/free并不允许重载。
4. new/delete会调用函数的构造函数/析构函数以完成对象的构造/析构。malloc则不会。
5. malloc和free是C++/C的标准库函数，new/delete是C++的运算符。
6. new操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。

<div style="text-align:center;">
    <img src="/img/guanjianzi_1.png" alt="区别1" style="max-width: 75%;height: auto;">
</div>


---

## volatile

与const绝对对立的类型修饰符，影响编译器编译结果，用该关键字声明的变量表示随时可能发生变化，与之相关的运算不要进行编译优化。会从内存中重新装载内容，而非直接从寄存器中拷贝内容。

**作用：**

指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值，保证对特殊地址的稳定访问。

**使用场合:**

中断服务程序和cpu相关寄存器的定义

**举例：**

```c++
for(volatile int i = 0; i < 100000; i++);//空循环，会一直执行不会被优化。
```

---

## extern

声明外部变量（在函数或者文件外部定义的全局变量）

---

## 总结

以上是一些关于C++中关键字的部分，其中部分是比较重要的东西需要牢牢掌握。

---


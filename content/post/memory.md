+++
title = 'C++内存重叠'
date = 2024-04-03T10:46:10+08:00
draft = false

+++

# C++内存重叠

**内存重叠**是指在内存中存在两个或多个区域，他们的地址范围有交叉部分，内存重叠可能会导致程序出现不可预期的行为，腾讯timi测开的三问面试官问到了我这个问题，当时没有回答上，非常的遗憾，现在有机会整理一下，变得更强！

## 内存重叠的原因

内存重叠的主要原因是指针的使用问题。当使用指针访问内存时，如果指针指向的内存区域与另一个区域有交叉部分，就会产生内存重叠。下图展示了内存拷贝的两种情况：

<div style="text-align: center;">
    <img src="/img/memory_1.png" alt="内存拷贝" style="max-width: 75%; height: auto;">
</div>

第一种情况下，拷贝重叠区域不会出现问题，因为拷贝是一个一个放过去，内容可以正常被拷贝。

第二种情况下，右边两个字节原有的内容被覆盖了，且没有保存，接下来拷贝的时候已经是被覆盖的内容了。

举个例子，下面代码片段就会导致内存重叠：

```c++
char str[] = "Hello World";
char* p = str +1;
memcpy(p, str, 11);
```

在上面代码中，定义了字符数组`str`，并使用`p`指向`str`中第二个字符。接着，我们用`memcpy`函数将`str`中的11个字符复制到`p`指向的区域。由于`p`指向的区域与`str`有交叉部分，因此就产生了内存重叠。因为`memcpy`是直接按位复制拷贝，代码如下，所以会遇到情况二，拷贝的是已经被覆盖的内容。

---

## 如何避免内存重叠

为了避免内存重叠，尤其要注意：

+ 尽量避免使用指针，尤其是进行运算和类型转换的时候。
+ 在使用指针时，确保指针指向的内存区域与其他区域没有交叉部分。
+ 在使用安全的内存操作函数，如`memcpy_s`、`memmove`等，这些函数可以确保在复制内存是不会产生内存重叠

那`memmove`如何避免内存重叠的影响呢？以下是`memmove`的源码：

```c++
void *memmove(void *dest, const void *src, size_t n)
{
    char *d = dest;
    const char *s = src;
    
    if(d < s) {
        while (n--)
            *d++ = *s++;
    }else{
        //采用倒序拷贝
        char *lasts = (char *)s + (n - 1);
        char *lastd = d + (n - 1);
        while(n--)
            *lastd-- = *lasts--;
    }
    
    return dest;
}
```

`remmove`判断如果`dest`>=`src`的时候（也就是前面图片的情况2），采用倒序拷贝，避免内容被覆盖导致拷贝不完整的问题。

原理图如下：

<div style="text-align: center;">
    <img src="/img/memory_2.png" alt="倒序拷贝" style="max-width: 75%; height: auto;">
</div>

`memcpy`与`strcpy`都有内存重叠的问题，实际可以根据需要使用`memmove`

---

## 总结

三面时候面试官告诉我这是一道思维题，现在想想也是，只用倒序拷贝就能避免粘贴内容被覆盖。但当时满脑子就是想着怎么避开他，诸如存放在别处再拿回来。笔者当时就走不动道了，现在想想一定给面试官留下了“深刻”的印象吧。以上内容既是逻辑题目，也是基础题目，当时抱着试试的想法是走不通的，还是得深入到位，把基础弄扎实，加油吧。
